<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>catmaid_publish.volumes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>catmaid_publish.volumes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
from collections import defaultdict
from collections.abc import Sequence
from functools import lru_cache
from pathlib import Path
from typing import Iterable, Optional, Union

import meshio
import navis
import networkx as nx
import numpy as np
import pandas as pd
import pymaid

from catmaid_publish.constants import CACHE_SIZE

from .utils import copy_cache, descendants, entity_graph, fill_in_dict


class AnnotatedVolume(navis.Volume):
    def __init__(
        self,
        vertices: Union[list, np.ndarray],
        faces: Union[list, np.ndarray] = None,
        name: Optional[str] = None,
        color: Union[str, Sequence[Union[int, float]]] = (0.85, 0.85, 0.85, 0.2),
        id: Optional[int] = None,
        annotations: Optional[set[str]] = None,
        **kwargs,
    ):
        super().__init__(vertices, faces, name, color, id, **kwargs)
        self.annotations = set() if not annotations else set(annotations)


def get_volume_id(vol: navis.Volume):
    &#34;&#34;&#34;Depends on some implementation details in both navis and trimesh.&#34;&#34;&#34;
    return vol._kwargs[&#34;volume_id&#34;]


def get_volumes(
    annotated: list[str],
    names: Optional[list[str]],
    rename: dict[str, str],
    ann_renames: dict[str, str],
) -&gt; tuple[dict[str, tuple[int, meshio.Mesh, set[str]]], dict[str, str]]:
    &#34;&#34;&#34;
    Returns 2-tuple:

    (
        {vol_renamed: (vol_id, mesh, renamed_annotations)},
        {orig_name: out_name}
    )
    &#34;&#34;&#34;

    name_to_anns = defaultdict(set)
    g = entity_graph()
    for v, d in g.nodes(data=True):
        if d[&#34;type&#34;] != &#34;volume&#34;:
            continue
        for parent in g.predecessors(v):
            parent_d = g.nodes[parent]
            if parent_d[&#34;type&#34;] != &#34;annotation&#34;:
                continue
            name_to_anns[d[&#34;name&#34;]].add(parent_d[&#34;name&#34;])

    if names is not None:
        name_set = set(rename)

        if annotated:
            ann_set = set(annotated)
            roots = [
                d[&#34;id&#34;]
                for _, d in g.nodes(data=True)
                if d[&#34;type&#34;] == &#34;annotation&#34; and d[&#34;name&#34;] in ann_set
            ]
            for vol_id in descendants(
                g, roots, select_fn=lambda _, d: d[&#34;type&#34;] == &#34;volume&#34;
            ):
                name_set.add(g.nodes[vol_id][&#34;name&#34;])

        name_set.update(names)
        names = sorted(name_set)

    volumes: dict[str, navis.Volume] = pymaid.get_volume(names)
    rename = fill_in_dict(rename, volumes.keys())

    out = {
        rename[name]: (
            get_volume_id(vol),
            meshio.Mesh(vol.vertices, [(&#34;triangle&#34;, vol.faces)]),
            {ann_renames[a] for a in name_to_anns[name] if a in ann_renames},
        )
        for name, vol in volumes.items()
    }

    return out, rename


def write_volumes(dpath: Path, volumes: dict[str, tuple[int, meshio.Mesh, set[str]]]):
    if not volumes:
        return
    dpath.mkdir(parents=True, exist_ok=True)

    ann_data = defaultdict(set)

    with open(dpath / &#34;names.tsv&#34;, &#34;w&#34;) as f:
        f.write(&#34;filename\tvolume_name\n&#34;)
        for name, (vol_id, mesh, anns) in sorted(volumes.items()):
            fname = str(vol_id) + &#34;.stl&#34;
            f.write(f&#34;{fname}\t{name}\n&#34;)
            mesh.write(dpath / fname)
            for ann in anns:
                ann_data[ann].add(name)

    with open(dpath / &#34;annotations.json&#34;, &#34;w&#34;) as f:
        json.dump({k: sorted(v) for k, v in ann_data.items()}, f)


def df_to_dict(df: pd.DataFrame, keys, values):
    return dict(zip(df[keys], df[values]))


class VolumeReader:
    &#34;&#34;&#34;Class for reading exported volume data.&#34;&#34;&#34;

    def __init__(self, dpath: Path) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        dpath : Path
            Path to directory in which the volume data is saved.
        &#34;&#34;&#34;
        self.dpath = dpath
        self._names_df = None

    @property
    def names_df(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Dataframe representing ``names.tsv``.

        Returns
        -------
        pd.DataFrame
            Columns ``filename``, ``volume_name``
        &#34;&#34;&#34;
        if self._names_df is None:
            self._names_df = pd.read_csv(
                self.dpath / &#34;names.tsv&#34;,
                sep=&#34;\t&#34;,
            )
        return self._names_df

    @lru_cache
    def _dict(self, keys, values):
        return df_to_dict(self.names_df, keys, values)

    @copy_cache(maxsize=None)
    def _get_annotations(self) -&gt; dict[str, set[str]]:
        &#34;&#34;&#34;Map annotation names to volume names.

        Returns
        -------
        dict[str, set[str]]
        &#34;&#34;&#34;
        d = json.loads((self.dpath / &#34;annotations.json&#34;).read_text())
        return {k: set(v) for k, v in d.items()}

    def get_annotation_graph(self) -&gt; nx.DiGraph:
        &#34;&#34;&#34;Get graph of annotations to volumes.

        Returns
        -------
        networkx.DiGraph
        &#34;&#34;&#34;
        g = nx.DiGraph()
        for k, vs in self._get_annotations().items():
            g.add_node(k, type=&#34;annotation&#34;)
            for v in vs:
                if v not in g.nodes:
                    g.add_node(v, type=&#34;volume&#34;)
                g.add_edge(k, v, meta_annotation=False)
        return g

    def _annotations_for_volume(self, name: str):
        d = self._get_annotations()
        return {a for a, names in d.items() if name in names}

    @copy_cache(maxsize=CACHE_SIZE)
    def _read_vol(
        self, fpath: Path, name: Optional[str], volume_id: Optional[int]
    ) -&gt; AnnotatedVolume:
        vol = AnnotatedVolume.from_file(fpath)
        if name is not None:
            d = self._dict(&#34;filename&#34;, &#34;volume_name&#34;)
            name = d[fpath.name]
        vol.name = name

        vol.annotations.update(self._annotations_for_volume(name))

        if volume_id is None:
            volume_id = int(fpath.stem)

        vol.id = volume_id
        return vol

    def get_by_id(self, volume_id: int) -&gt; AnnotatedVolume:
        &#34;&#34;&#34;Read a volume with a given (arbitrary) ID.

        Parameters
        ----------
        volume_id : int

        Returns
        -------
        AnnotatedVolume
        &#34;&#34;&#34;
        return self._read_vol(
            self.dpath / f&#34;{volume_id}.stl&#34;,
            None,
            volume_id,
        )

    def get_by_name(self, volume_name: str) -&gt; AnnotatedVolume:
        &#34;&#34;&#34;Read a volume with a given name.

        Parameters
        ----------
        volume_name : str

        Returns
        -------
        AnnotatedVolume
        &#34;&#34;&#34;
        d = self._dict(&#34;volume_name&#34;, &#34;filename&#34;)
        fname = d[volume_name]
        path = self.dpath / fname
        return self._read_vol(path, volume_name, None)

    def get_by_annotation(self, annotation: str) -&gt; Iterable[AnnotatedVolume]:
        &#34;&#34;&#34;Lazily iterate through all volumes with the given annotation.

        Parameters
        ----------
        annotation : str
            Annotation name.

        Yields
        ------
        Iterable[AnnotatedVolume]
        &#34;&#34;&#34;
        d = self._get_annotations()
        for vol_name in d[annotation]:
            yield self.get_by_name(vol_name)

    def get_all(self) -&gt; Iterable[AnnotatedVolume]:
        &#34;&#34;&#34;Lazily iterate through all available volumes.

        Iteration is in the order used by ``names.tsv``.

        Yields
        ------
        AnnotatedVolume
        &#34;&#34;&#34;
        for fname, name in self._dict(&#34;filename&#34;, &#34;volume_name&#34;).items():
            fpath = self.dpath / fname
            yield self._read_vol(fpath, name, None)


README = &#34;&#34;&#34;
# Volumes

Volumes are regions of interest represented by 3D triangular meshes.

Data in this directory can be parsed into `AnnotatedVolume`s
(a subclass of `navis.Volume` which simply adds an attribute `annotations: set[str]`)
using `catmaid_publish.VolumeReader`.

## Files

### `names.tsv`

A tab separated value file with columns
`filename`, `volume_name`.
This maps the name of the volume to the name of the file in which the mesh is stored.

### `*.stl`

Files representing the volume, in ASCII STL format, named with an arbitrary ID.

### `annotations.json`

A JSON file mapping annotation names to an array of the names of volumes it annotates.
&#34;&#34;&#34;.lstrip()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="catmaid_publish.volumes.df_to_dict"><code class="name flex">
<span>def <span class="ident">df_to_dict</span></span>(<span>df: pandas.core.frame.DataFrame, keys, values)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def df_to_dict(df: pd.DataFrame, keys, values):
    return dict(zip(df[keys], df[values]))</code></pre>
</details>
</dd>
<dt id="catmaid_publish.volumes.get_volume_id"><code class="name flex">
<span>def <span class="ident">get_volume_id</span></span>(<span>vol: navis.core.volumes.Volume)</span>
</code></dt>
<dd>
<div class="desc"><p>Depends on some implementation details in both navis and trimesh.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_volume_id(vol: navis.Volume):
    &#34;&#34;&#34;Depends on some implementation details in both navis and trimesh.&#34;&#34;&#34;
    return vol._kwargs[&#34;volume_id&#34;]</code></pre>
</details>
</dd>
<dt id="catmaid_publish.volumes.get_volumes"><code class="name flex">
<span>def <span class="ident">get_volumes</span></span>(<span>annotated: list[str], names: Optional[list[str]], rename: dict[str, str], ann_renames: dict[str, str]) ‑> tuple[dict[str, tuple[int, meshio._mesh.Mesh, set[str]]], dict[str, str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns 2-tuple:</p>
<p>(
{vol_renamed: (vol_id, mesh, renamed_annotations)},
{orig_name: out_name}
)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_volumes(
    annotated: list[str],
    names: Optional[list[str]],
    rename: dict[str, str],
    ann_renames: dict[str, str],
) -&gt; tuple[dict[str, tuple[int, meshio.Mesh, set[str]]], dict[str, str]]:
    &#34;&#34;&#34;
    Returns 2-tuple:

    (
        {vol_renamed: (vol_id, mesh, renamed_annotations)},
        {orig_name: out_name}
    )
    &#34;&#34;&#34;

    name_to_anns = defaultdict(set)
    g = entity_graph()
    for v, d in g.nodes(data=True):
        if d[&#34;type&#34;] != &#34;volume&#34;:
            continue
        for parent in g.predecessors(v):
            parent_d = g.nodes[parent]
            if parent_d[&#34;type&#34;] != &#34;annotation&#34;:
                continue
            name_to_anns[d[&#34;name&#34;]].add(parent_d[&#34;name&#34;])

    if names is not None:
        name_set = set(rename)

        if annotated:
            ann_set = set(annotated)
            roots = [
                d[&#34;id&#34;]
                for _, d in g.nodes(data=True)
                if d[&#34;type&#34;] == &#34;annotation&#34; and d[&#34;name&#34;] in ann_set
            ]
            for vol_id in descendants(
                g, roots, select_fn=lambda _, d: d[&#34;type&#34;] == &#34;volume&#34;
            ):
                name_set.add(g.nodes[vol_id][&#34;name&#34;])

        name_set.update(names)
        names = sorted(name_set)

    volumes: dict[str, navis.Volume] = pymaid.get_volume(names)
    rename = fill_in_dict(rename, volumes.keys())

    out = {
        rename[name]: (
            get_volume_id(vol),
            meshio.Mesh(vol.vertices, [(&#34;triangle&#34;, vol.faces)]),
            {ann_renames[a] for a in name_to_anns[name] if a in ann_renames},
        )
        for name, vol in volumes.items()
    }

    return out, rename</code></pre>
</details>
</dd>
<dt id="catmaid_publish.volumes.write_volumes"><code class="name flex">
<span>def <span class="ident">write_volumes</span></span>(<span>dpath: pathlib.Path, volumes: dict[str, tuple[int, meshio._mesh.Mesh, set[str]]])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_volumes(dpath: Path, volumes: dict[str, tuple[int, meshio.Mesh, set[str]]]):
    if not volumes:
        return
    dpath.mkdir(parents=True, exist_ok=True)

    ann_data = defaultdict(set)

    with open(dpath / &#34;names.tsv&#34;, &#34;w&#34;) as f:
        f.write(&#34;filename\tvolume_name\n&#34;)
        for name, (vol_id, mesh, anns) in sorted(volumes.items()):
            fname = str(vol_id) + &#34;.stl&#34;
            f.write(f&#34;{fname}\t{name}\n&#34;)
            mesh.write(dpath / fname)
            for ann in anns:
                ann_data[ann].add(name)

    with open(dpath / &#34;annotations.json&#34;, &#34;w&#34;) as f:
        json.dump({k: sorted(v) for k, v in ann_data.items()}, f)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="catmaid_publish.volumes.AnnotatedVolume"><code class="flex name class">
<span>class <span class="ident">AnnotatedVolume</span></span>
<span>(</span><span>vertices: Union[list, numpy.ndarray], faces: Union[list, numpy.ndarray] = None, name: Optional[str] = None, color: Union[str, collections.abc.Sequence[Union[int, float]]] = (0.85, 0.85, 0.85, 0.2), id: Optional[int] = None, annotations: Optional[set[str]] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Mesh consisting of vertices and faces.</p>
<p>Subclass of <code>trimesh.Trimesh</code> with a few additional methods.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vertices</code></strong> :&ensp;<code>list | array | mesh-like</code></dt>
<dd><code>(N, 3)</code> vertices coordinates or an object that has
<code>.vertices</code> and <code>.faces</code> attributes in which case <code>faces</code>
parameter will be ignored.</dd>
<dt><strong><code>faces</code></strong> :&ensp;<code>list | array</code></dt>
<dd><code>(M, 3)</code> array of indexed triangle faces.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>
str</code>, optional</dt>
<dd>A name for the volume.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>
tuple</code>, optional</dt>
<dd>RGB(A) color.</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>
int</code>, optional</dt>
<dd>If not provided, neuron will be assigned a random UUID as <code>.id</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Keyword arguments passed through to <code>trimesh.Trimesh</code></dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>:func:</code>~navis.example_volume<code> Loads example volume(s).</code></p>
<p><code>A Trimesh object contains a triangular 3D mesh.</code></p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>vertices</code></strong> :&ensp;<code>(n, 3) float</code></dt>
<dd>&nbsp;</dd>
<dt>Array of vertex locations</dt>
<dt><strong><code>faces</code></strong> :&ensp;<code>(m, 3)</code> or <code>(m, 4) int</code></dt>
<dd>&nbsp;</dd>
<dt>Array of triangular or quad faces (triangulated on load)</dt>
<dt><strong><code>face_normals</code></strong> :&ensp;<code>(m, 3) float</code></dt>
<dd>&nbsp;</dd>
<dt>Array of normal vectors corresponding to faces</dt>
<dt><strong><code>vertex_normals</code></strong> :&ensp;<code>(n, 3) float</code></dt>
<dd>&nbsp;</dd>
<dt>Array of normal vectors for vertices</dt>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
<dt>Any metadata about the mesh</dt>
<dt><strong><code>process</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt>if True, Nan and Inf values will be removed</dt>
<dt>immediately and vertices will be merged</dt>
<dt><strong><code>validate</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt>If True, degenerate and duplicate faces will be</dt>
<dt>removed immediately, and some functions will alter</dt>
<dt>the mesh to ensure consistent results.</dt>
<dt><strong><code>use_embree</code></strong> :&ensp;<code>bool</code></dt>
<dd>&nbsp;</dd>
<dt>If True try to use pyembree raytracer.</dt>
<dt>If pyembree is not available it will automatically fall</dt>
<dt>back to a much slower rtree/numpy implementation</dt>
<dt><strong><code>initial_cache</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
<dt>A way to pass things to the cache in case expensive</dt>
<dt>things were calculated before creating the mesh object.</dt>
<dt><strong><code>visual</code></strong> :&ensp;<code>ColorVisuals</code> or <code>TextureVisuals</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Assigned to self.visual</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AnnotatedVolume(navis.Volume):
    def __init__(
        self,
        vertices: Union[list, np.ndarray],
        faces: Union[list, np.ndarray] = None,
        name: Optional[str] = None,
        color: Union[str, Sequence[Union[int, float]]] = (0.85, 0.85, 0.85, 0.2),
        id: Optional[int] = None,
        annotations: Optional[set[str]] = None,
        **kwargs,
    ):
        super().__init__(vertices, faces, name, color, id, **kwargs)
        self.annotations = set() if not annotations else set(annotations)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>navis.core.volumes.Volume</li>
<li>trimesh.base.Trimesh</li>
<li>trimesh.parent.Geometry3D</li>
<li>trimesh.parent.Geometry</li>
<li>abc.ABC</li>
</ul>
</dd>
<dt id="catmaid_publish.volumes.VolumeReader"><code class="flex name class">
<span>class <span class="ident">VolumeReader</span></span>
<span>(</span><span>dpath: pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for reading exported volume data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dpath</code></strong> :&ensp;<code>Path</code></dt>
<dd>Path to directory in which the volume data is saved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VolumeReader:
    &#34;&#34;&#34;Class for reading exported volume data.&#34;&#34;&#34;

    def __init__(self, dpath: Path) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        dpath : Path
            Path to directory in which the volume data is saved.
        &#34;&#34;&#34;
        self.dpath = dpath
        self._names_df = None

    @property
    def names_df(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Dataframe representing ``names.tsv``.

        Returns
        -------
        pd.DataFrame
            Columns ``filename``, ``volume_name``
        &#34;&#34;&#34;
        if self._names_df is None:
            self._names_df = pd.read_csv(
                self.dpath / &#34;names.tsv&#34;,
                sep=&#34;\t&#34;,
            )
        return self._names_df

    @lru_cache
    def _dict(self, keys, values):
        return df_to_dict(self.names_df, keys, values)

    @copy_cache(maxsize=None)
    def _get_annotations(self) -&gt; dict[str, set[str]]:
        &#34;&#34;&#34;Map annotation names to volume names.

        Returns
        -------
        dict[str, set[str]]
        &#34;&#34;&#34;
        d = json.loads((self.dpath / &#34;annotations.json&#34;).read_text())
        return {k: set(v) for k, v in d.items()}

    def get_annotation_graph(self) -&gt; nx.DiGraph:
        &#34;&#34;&#34;Get graph of annotations to volumes.

        Returns
        -------
        networkx.DiGraph
        &#34;&#34;&#34;
        g = nx.DiGraph()
        for k, vs in self._get_annotations().items():
            g.add_node(k, type=&#34;annotation&#34;)
            for v in vs:
                if v not in g.nodes:
                    g.add_node(v, type=&#34;volume&#34;)
                g.add_edge(k, v, meta_annotation=False)
        return g

    def _annotations_for_volume(self, name: str):
        d = self._get_annotations()
        return {a for a, names in d.items() if name in names}

    @copy_cache(maxsize=CACHE_SIZE)
    def _read_vol(
        self, fpath: Path, name: Optional[str], volume_id: Optional[int]
    ) -&gt; AnnotatedVolume:
        vol = AnnotatedVolume.from_file(fpath)
        if name is not None:
            d = self._dict(&#34;filename&#34;, &#34;volume_name&#34;)
            name = d[fpath.name]
        vol.name = name

        vol.annotations.update(self._annotations_for_volume(name))

        if volume_id is None:
            volume_id = int(fpath.stem)

        vol.id = volume_id
        return vol

    def get_by_id(self, volume_id: int) -&gt; AnnotatedVolume:
        &#34;&#34;&#34;Read a volume with a given (arbitrary) ID.

        Parameters
        ----------
        volume_id : int

        Returns
        -------
        AnnotatedVolume
        &#34;&#34;&#34;
        return self._read_vol(
            self.dpath / f&#34;{volume_id}.stl&#34;,
            None,
            volume_id,
        )

    def get_by_name(self, volume_name: str) -&gt; AnnotatedVolume:
        &#34;&#34;&#34;Read a volume with a given name.

        Parameters
        ----------
        volume_name : str

        Returns
        -------
        AnnotatedVolume
        &#34;&#34;&#34;
        d = self._dict(&#34;volume_name&#34;, &#34;filename&#34;)
        fname = d[volume_name]
        path = self.dpath / fname
        return self._read_vol(path, volume_name, None)

    def get_by_annotation(self, annotation: str) -&gt; Iterable[AnnotatedVolume]:
        &#34;&#34;&#34;Lazily iterate through all volumes with the given annotation.

        Parameters
        ----------
        annotation : str
            Annotation name.

        Yields
        ------
        Iterable[AnnotatedVolume]
        &#34;&#34;&#34;
        d = self._get_annotations()
        for vol_name in d[annotation]:
            yield self.get_by_name(vol_name)

    def get_all(self) -&gt; Iterable[AnnotatedVolume]:
        &#34;&#34;&#34;Lazily iterate through all available volumes.

        Iteration is in the order used by ``names.tsv``.

        Yields
        ------
        AnnotatedVolume
        &#34;&#34;&#34;
        for fname, name in self._dict(&#34;filename&#34;, &#34;volume_name&#34;).items():
            fpath = self.dpath / fname
            yield self._read_vol(fpath, name, None)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="catmaid_publish.volumes.VolumeReader.names_df"><code class="name">var <span class="ident">names_df</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"><p>Dataframe representing <code>names.tsv</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Columns <code>filename</code>, <code>volume_name</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def names_df(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Dataframe representing ``names.tsv``.

    Returns
    -------
    pd.DataFrame
        Columns ``filename``, ``volume_name``
    &#34;&#34;&#34;
    if self._names_df is None:
        self._names_df = pd.read_csv(
            self.dpath / &#34;names.tsv&#34;,
            sep=&#34;\t&#34;,
        )
    return self._names_df</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="catmaid_publish.volumes.VolumeReader.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>self) ‑> Iterable[<a title="catmaid_publish.volumes.AnnotatedVolume" href="#catmaid_publish.volumes.AnnotatedVolume">AnnotatedVolume</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily iterate through all available volumes.</p>
<p>Iteration is in the order used by <code>names.tsv</code>.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="catmaid_publish.volumes.AnnotatedVolume" href="#catmaid_publish.volumes.AnnotatedVolume">AnnotatedVolume</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(self) -&gt; Iterable[AnnotatedVolume]:
    &#34;&#34;&#34;Lazily iterate through all available volumes.

    Iteration is in the order used by ``names.tsv``.

    Yields
    ------
    AnnotatedVolume
    &#34;&#34;&#34;
    for fname, name in self._dict(&#34;filename&#34;, &#34;volume_name&#34;).items():
        fpath = self.dpath / fname
        yield self._read_vol(fpath, name, None)</code></pre>
</details>
</dd>
<dt id="catmaid_publish.volumes.VolumeReader.get_annotation_graph"><code class="name flex">
<span>def <span class="ident">get_annotation_graph</span></span>(<span>self) ‑> networkx.classes.digraph.DiGraph</span>
</code></dt>
<dd>
<div class="desc"><p>Get graph of annotations to volumes.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>networkx.DiGraph</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotation_graph(self) -&gt; nx.DiGraph:
    &#34;&#34;&#34;Get graph of annotations to volumes.

    Returns
    -------
    networkx.DiGraph
    &#34;&#34;&#34;
    g = nx.DiGraph()
    for k, vs in self._get_annotations().items():
        g.add_node(k, type=&#34;annotation&#34;)
        for v in vs:
            if v not in g.nodes:
                g.add_node(v, type=&#34;volume&#34;)
            g.add_edge(k, v, meta_annotation=False)
    return g</code></pre>
</details>
</dd>
<dt id="catmaid_publish.volumes.VolumeReader.get_by_annotation"><code class="name flex">
<span>def <span class="ident">get_by_annotation</span></span>(<span>self, annotation: str) ‑> Iterable[<a title="catmaid_publish.volumes.AnnotatedVolume" href="#catmaid_publish.volumes.AnnotatedVolume">AnnotatedVolume</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily iterate through all volumes with the given annotation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>annotation</code></strong> :&ensp;<code>str</code></dt>
<dd>Annotation name.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>Iterable[<a title="catmaid_publish.volumes.AnnotatedVolume" href="#catmaid_publish.volumes.AnnotatedVolume">AnnotatedVolume</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_annotation(self, annotation: str) -&gt; Iterable[AnnotatedVolume]:
    &#34;&#34;&#34;Lazily iterate through all volumes with the given annotation.

    Parameters
    ----------
    annotation : str
        Annotation name.

    Yields
    ------
    Iterable[AnnotatedVolume]
    &#34;&#34;&#34;
    d = self._get_annotations()
    for vol_name in d[annotation]:
        yield self.get_by_name(vol_name)</code></pre>
</details>
</dd>
<dt id="catmaid_publish.volumes.VolumeReader.get_by_id"><code class="name flex">
<span>def <span class="ident">get_by_id</span></span>(<span>self, volume_id: int) ‑> <a title="catmaid_publish.volumes.AnnotatedVolume" href="#catmaid_publish.volumes.AnnotatedVolume">AnnotatedVolume</a></span>
</code></dt>
<dd>
<div class="desc"><p>Read a volume with a given (arbitrary) ID.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>volume_id</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="catmaid_publish.volumes.AnnotatedVolume" href="#catmaid_publish.volumes.AnnotatedVolume">AnnotatedVolume</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_id(self, volume_id: int) -&gt; AnnotatedVolume:
    &#34;&#34;&#34;Read a volume with a given (arbitrary) ID.

    Parameters
    ----------
    volume_id : int

    Returns
    -------
    AnnotatedVolume
    &#34;&#34;&#34;
    return self._read_vol(
        self.dpath / f&#34;{volume_id}.stl&#34;,
        None,
        volume_id,
    )</code></pre>
</details>
</dd>
<dt id="catmaid_publish.volumes.VolumeReader.get_by_name"><code class="name flex">
<span>def <span class="ident">get_by_name</span></span>(<span>self, volume_name: str) ‑> <a title="catmaid_publish.volumes.AnnotatedVolume" href="#catmaid_publish.volumes.AnnotatedVolume">AnnotatedVolume</a></span>
</code></dt>
<dd>
<div class="desc"><p>Read a volume with a given name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>volume_name</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="catmaid_publish.volumes.AnnotatedVolume" href="#catmaid_publish.volumes.AnnotatedVolume">AnnotatedVolume</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_name(self, volume_name: str) -&gt; AnnotatedVolume:
    &#34;&#34;&#34;Read a volume with a given name.

    Parameters
    ----------
    volume_name : str

    Returns
    -------
    AnnotatedVolume
    &#34;&#34;&#34;
    d = self._dict(&#34;volume_name&#34;, &#34;filename&#34;)
    fname = d[volume_name]
    path = self.dpath / fname
    return self._read_vol(path, volume_name, None)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="catmaid_publish" href="index.html">catmaid_publish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="catmaid_publish.volumes.df_to_dict" href="#catmaid_publish.volumes.df_to_dict">df_to_dict</a></code></li>
<li><code><a title="catmaid_publish.volumes.get_volume_id" href="#catmaid_publish.volumes.get_volume_id">get_volume_id</a></code></li>
<li><code><a title="catmaid_publish.volumes.get_volumes" href="#catmaid_publish.volumes.get_volumes">get_volumes</a></code></li>
<li><code><a title="catmaid_publish.volumes.write_volumes" href="#catmaid_publish.volumes.write_volumes">write_volumes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="catmaid_publish.volumes.AnnotatedVolume" href="#catmaid_publish.volumes.AnnotatedVolume">AnnotatedVolume</a></code></h4>
</li>
<li>
<h4><code><a title="catmaid_publish.volumes.VolumeReader" href="#catmaid_publish.volumes.VolumeReader">VolumeReader</a></code></h4>
<ul class="">
<li><code><a title="catmaid_publish.volumes.VolumeReader.get_all" href="#catmaid_publish.volumes.VolumeReader.get_all">get_all</a></code></li>
<li><code><a title="catmaid_publish.volumes.VolumeReader.get_annotation_graph" href="#catmaid_publish.volumes.VolumeReader.get_annotation_graph">get_annotation_graph</a></code></li>
<li><code><a title="catmaid_publish.volumes.VolumeReader.get_by_annotation" href="#catmaid_publish.volumes.VolumeReader.get_by_annotation">get_by_annotation</a></code></li>
<li><code><a title="catmaid_publish.volumes.VolumeReader.get_by_id" href="#catmaid_publish.volumes.VolumeReader.get_by_id">get_by_id</a></code></li>
<li><code><a title="catmaid_publish.volumes.VolumeReader.get_by_name" href="#catmaid_publish.volumes.VolumeReader.get_by_name">get_by_name</a></code></li>
<li><code><a title="catmaid_publish.volumes.VolumeReader.names_df" href="#catmaid_publish.volumes.VolumeReader.names_df">names_df</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>