<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>catmaid_publish.skeletons API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>catmaid_publish.skeletons</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import logging
from collections import defaultdict
from collections.abc import Iterable
from functools import lru_cache
from pathlib import Path
from typing import Any, NamedTuple, Optional, Sequence

import navis
import networkx as nx
import numpy as np
import pandas as pd
import pymaid
from tqdm import tqdm

from .constants import CACHE_SIZE
from .utils import copy_cache, descendants, entity_graph, fill_in_dict

logger = logging.getLogger(__name__)


def get_all_skids():
    try:
        # once https://github.com/navis-org/pymaid/pull/227 is released
        return pymaid.get_skeleton_ids()
    except ImportError:
        pass

    cm = pymaid.utils._eval_remote_instance(None)
    url = cm.make_url(
        cm.project_id,
        &#34;skeletons&#34;,
    )
    return set(cm.fetch(url))


def filter_tags(
    tags: dict[str, list[int]], names: Optional[list[str]], rename: dict[str, str]
):
    if names is None:
        rename = fill_in_dict(rename, list(tags))
    else:
        rename = fill_in_dict(rename, names)

    return {rename[k]: sorted(v) for k, v in tags.items() if k in rename}


def get_renamed_annotations(
    nrn: pymaid.CatmaidNeuron, rename: dict[str, str]
) -&gt; set[str]:
    anns = nrn.get_annotations()
    return {rename[a] for a in anns if a in rename}


def sub_annotations(ann_names: list[str]):
    g = entity_graph()
    an = set(ann_names)
    ann_ids = descendants(
        g,
        [
            n
            for n, d in g.nodes(data=True)
            if d[&#34;type&#34;] == &#34;annotation&#34; and d[&#34;name&#34;] in an
        ],
        select_fn=(lambda n, d: d[&#34;type&#34;] == &#34;annotation&#34;),
    )
    return [g.nodes[a][&#34;name&#34;] for a in ann_ids]


def get_skeletons(
    annotated: list[str],
    names: Optional[list[str]],
    rename: dict[str, str],
    tag_names: Optional[list[str]],
    tag_rename: dict[str, str],
    annotations_rename: dict[str, str],
) -&gt; Iterable[tuple[pymaid.CatmaidNeuron, dict[str, Any]]]:
    if names is None:
        skids = get_all_skids()
    else:
        skids = set()
        if names:
            skids.update(pymaid.get_skids_by_name(names))
        if rename:
            skids.update(pymaid.get_skids_by_name(list(rename)))
        if annotated:
            all_anns = sub_annotations(annotated)
            skids.update(pymaid.get_skids_by_annotation(all_anns))

    logger.warning(&#34;Fetching %s skeletons, may be slow&#34;, len(skids))
    neurons: pymaid.CatmaidNeuronList = pymaid.get_neuron(sorted(skids))

    nrn: pymaid.CatmaidNeuron
    for nrn in tqdm(neurons, desc=&#34;Finalising neurons&#34;):
        nrn.name = rename.get(nrn.name, nrn.name)
        nrn.tags = filter_tags(nrn.tags, tag_names, tag_rename)
        anns = get_renamed_annotations(nrn, annotations_rename)
        meta = {
            &#34;name&#34;: fn_or_none(nrn.name, str),
            &#34;skeleton_id&#34;: int(nrn.id),
            &#34;soma_id&#34;: fn_or_none(nrn.soma, int),
            &#34;annotations&#34;: sorted(anns),
        }
        yield nrn, meta


def fn_or_none(item, fn):
    if item is None:
        return None
    return fn(item)


def sort_skel_dfs(df: pd.DataFrame, roots, sort_children=True, inplace=False):
    &#34;&#34;&#34;Depth-first search tree to ensure parents are always defined before children.&#34;&#34;&#34;
    children = defaultdict(list)
    node_id_to_orig_idx = dict()
    for row in df.itertuples():
        child = row.node_id
        parent = row.parent_id
        children[parent].append(child)
        node_id_to_orig_idx[child] = row.Index

    if sort_children:
        to_visit = sorted(roots, reverse=True)
    else:
        to_visit = list(roots)[::-1]

    order = np.full(len(df), np.nan)
    count = 0
    while to_visit:
        node_id = to_visit.pop()
        order[node_id_to_orig_idx[node_id]] = count
        cs = children.pop(order[-1], [])
        if sort_children:
            to_visit.extend(sorted(cs, reverse=True))
        else:
            to_visit.extend(cs[::-1])
        count += 1

    # undefined behaviour if any nodes are not reachable from the given roots

    if not inplace:
        df = df.copy()

    df[&#34;_order&#34;] = order
    df.sort_values(&#34;_order&#34;, inplace=True)
    df.drop(columns=[&#34;_order&#34;], inplace=True)
    return df


def write_skeleton(dpath: Path, nrn: pymaid.CatmaidNeuron, meta: dict[str, Any]):
    dpath.mkdir(parents=True)

    with open(dpath / &#34;metadata.json&#34;, &#34;w&#34;) as f:
        json.dump(meta, f, indent=2, sort_keys=True)

    with open(dpath / &#34;tags.json&#34;, &#34;w&#34;) as f:
        json.dump(nrn.tags, f, sort_keys=True, indent=2)

    nodes = sort_skel_dfs(
        nrn.nodes[[&#34;node_id&#34;, &#34;parent_id&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;radius&#34;]],
        nrn.root,
    )
    nodes.to_csv(dpath / &#34;nodes.tsv&#34;, sep=&#34;\t&#34;, index=False)

    conns = nrn.connectors.sort_values(&#34;node_id&#34;, inplace=False)
    conns.rename(columns={&#34;type&#34;: &#34;is_input&#34;}, inplace=True)
    conns.to_csv(dpath / &#34;connectors.tsv&#34;, sep=&#34;\t&#34;, index=False)


class ReadSpec(NamedTuple):
    &#34;&#34;&#34;Specify a subset of a skeleton&#39;s data to read.&#34;&#34;&#34;

    nodes: bool = True
    connectors: bool = True
    tags: bool = True

    def copy(self, nodes=None, connectors=None, tags=None):
        return type(self)(
            nodes=nodes if nodes is not None else self.nodes,
            connectors=connectors if connectors is not None else self.connectors,
            tags=tags if tags is not None else self.tags,
        )


class SkeletonReader:
    &#34;&#34;&#34;Class for reading exported skeletonised neuron data.

    Most &#34;get_&#34; methods take a ``read_spec`` argument.
    This is a 3-(named)tuple of bools representing
    whether to populate the nodes, connectors, and tags fields
    of the returned TreeNeuron objects.
    By default, all will be populated.
    Metadata is always populated.
    &#34;&#34;&#34;

    def __init__(self, dpath: Path, units=None, read_spec=ReadSpec()) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        dpath : Path
            Directory in which the neuron data is saved.
        &#34;&#34;&#34;
        self.dpath = dpath
        self.units = units
        self.default_read_spec = ReadSpec(*read_spec)

    @copy_cache(maxsize=CACHE_SIZE)
    def _read_meta(self, dpath):
        return json.loads((dpath / &#34;metadata.json&#34;).read_text())

    @copy_cache(maxsize=CACHE_SIZE)
    def _read_nodes(self, dpath):
        return pd.read_csv(dpath / &#34;nodes.tsv&#34;, sep=&#34;\t&#34;)

    @copy_cache(maxsize=CACHE_SIZE)
    def _read_tags(self, dpath):
        return json.loads((dpath / &#34;tags.json&#34;).read_text())

    @copy_cache(maxsize=CACHE_SIZE)
    def _read_connectors(self, dpath):
        conns = pd.read_csv(dpath / &#34;connectors.tsv&#34;, sep=&#34;\t&#34;)
        conns.rename(columns={&#34;is_input&#34;: &#34;type&#34;}, inplace=True)
        return conns

    def parse_read_spec(self, read_spec: Optional[Sequence[bool]] = None) -&gt; ReadSpec:
        if read_spec is None:
            read_spec = self.default_read_spec
        else:
            read_spec = ReadSpec(*read_spec)
        return read_spec

    def _construct_neuron(self, meta, nodes=None, tags=None, connectors=None):
        nrn = navis.TreeNeuron(nodes, self.units, annotations=meta[&#34;annotations&#34;])
        nrn.id = meta[&#34;id&#34;]
        nrn.name = meta[&#34;name&#34;]
        nrn.soma = meta[&#34;soma_id&#34;]

        nrn.tags = tags
        nrn.connectors = connectors
        return nrn

    def _read_neuron(
        self, dpath, read_spec: Optional[ReadSpec] = None
    ) -&gt; navis.TreeNeuron:
        read_spec = self.parse_read_spec(read_spec)

        meta = self._read_meta(dpath)

        if read_spec.nodes:
            nodes = self._read_nodes(dpath)
        else:
            nodes = None

        if read_spec.tags:
            tags = self._read_tags(dpath)
        else:
            tags = None

        if read_spec.connectors:
            connectors = self._read_connectors(dpath)
        else:
            connectors = None

        return self._construct_neuron(meta, nodes, tags, connectors)

    def get_by_id(
        self, skeleton_id: int, read_spec: Optional[ReadSpec] = None
    ) -&gt; navis.TreeNeuron:
        &#34;&#34;&#34;Read neuron with the given skeleton ID.

        Parameters
        ----------
        skeleton_id : int

        Returns
        -------
        navis.TreeNeuron
        &#34;&#34;&#34;
        return self._read_neuron(self.dpath / str(skeleton_id), read_spec)

    def _iter_dirs(self):
        for path in self.dpath.iterdir():
            if path.is_dir():
                yield path

    @lru_cache
    def name_to_id(self) -&gt; dict[str, int]:
        &#34;&#34;&#34;Mapping from neuron name to skeleton ID.

        Returns
        -------
        dict[str, int]
        &#34;&#34;&#34;
        out = dict()

        for dpath in self._iter_dirs():
            meta = self._read_meta(dpath)
            out[meta[&#34;name&#34;]] = meta[&#34;id&#34;]

        return out

    @lru_cache
    def annotation_to_ids(self) -&gt; dict[str, list[int]]:
        &#34;&#34;&#34;Which skeletons string annotations are applied to.

        Returns
        -------
        dict[str, list[int]]
            Mapping from annotation name to list of skeleton IDs.
        &#34;&#34;&#34;
        out: dict[str, list[int]] = dict()

        for dpath in self._iter_dirs():
            meta = self._read_meta(dpath)
            for ann in meta[&#34;annotations&#34;]:
                out.setdefault(ann, []).append(meta[&#34;id&#34;])

        return out

    def get_by_name(
        self, name: str, read_spec: Optional[ReadSpec] = None
    ) -&gt; navis.TreeNeuron:
        &#34;&#34;&#34;Read neuron with the given name.

        Parameters
        ----------
        name : str
            Exact neuron name.

        Returns
        -------
        navis.TreeNeuron
        &#34;&#34;&#34;
        d = self.name_to_id()
        return self.get_by_id(d[name], read_spec)

    def get_by_annotation(
        self, annotation: str, read_spec: Optional[ReadSpec] = None
    ) -&gt; Iterable[navis.TreeNeuron]:
        &#34;&#34;&#34;Lazily iterate through neurons with the given annotation.

        Parameters
        ----------
        annotation : str
            Exact annotation.

        Yields
        ------
        navis.TreeNeuron
        &#34;&#34;&#34;
        d = self.annotation_to_ids()
        for skid in d[annotation]:
            yield self.get_by_id(skid, read_spec)

    def get_annotation_names(self) -&gt; set[str]:
        &#34;&#34;&#34;Return all annotations represented in the dataset.

        Returns
        -------
        set[str]
            Set of annotation names.
        &#34;&#34;&#34;
        d = self.annotation_to_ids()
        return set(d)

    def get_annotation_graph(self) -&gt; nx.DiGraph:
        &#34;&#34;&#34;Return graph of neuron annotations.

        Returns
        -------
        nx.DiGraph
            Edges are from annotations to neuron names.
            All nodes have attribute ``&#34;type&#34;``,
            which is either ``&#34;neuron&#34;`` or ``&#34;annotation&#34;``.
            All edges have attribute ``&#34;meta_annotation&#34;=False``.
        &#34;&#34;&#34;
        g = nx.DiGraph()
        anns = set()
        neurons = set()
        for dpath in self._iter_dirs():
            meta = self._read_meta(dpath)
            name = meta[&#34;name&#34;]
            neurons.add(name)
            for ann in meta[&#34;annotations&#34;]:
                anns.add(ann)
                g.add_edge(ann, name, meta_annotation=False)

        ann_data = {&#34;type&#34;: &#34;annotation&#34;}
        for ann in anns:
            g.nodes[ann].update(ann_data)

        return g

    def get_all(
        self, read_spec: Optional[ReadSpec] = None
    ) -&gt; Iterable[navis.TreeNeuron]:
        &#34;&#34;&#34;Lazily iterate through neurons in arbitrary order.

        Can be used for filtering neurons based on some metadata, e.g.

            lefts = []
            for nrn in my_reader.get_all(ReadSpec(False, False, False)):
                if &#34;left&#34; in nrn.name:
                    lefts.append(my_reader.get_by_id(nrn.id)))

        Yields
        ------
        navis.TreeNeuron
        &#34;&#34;&#34;
        for dpath in self._iter_dirs():
            yield self._read_neuron(dpath, read_spec)


README = &#34;&#34;&#34;
# Neurons

Each neuron is represented by a directory whose name is an arbitrary integer ID associated with the neuron.
A neuron is represented by a skeleton:
a tree graph of points in 3D space (&#34;nodes&#34;) which each have an integer ID.
Neurons also have tags: text labels applied to certain nodes.
Synapses between neurons are represented as connectors:
a point in 3D space associated with a node, which may be an input or an output.
Finally, neurons have some associated metadata,
including their name, a set of annotations
(text labels associated with the neuron rather than its nodes),
and optionally the node ID of the neuron&#39;s soma.

Data in this directory can be parsed into `navis.TreeNeuron`s
using `catmaid_publish.NeuronReader`.

## Files

### `*/nodes.tsv`

A tab separated value file with columns
`node_id` (int), `parent_id` (int), `x`, `y`, `z`, `radius` (all decimal).

A `parent_id` of `-1` indicates that the node does not have a parent, i.e. is the root.
Otherwise, `parent_id` refers to the `node_id` of the node&#39;s parent.
A `radius` of `-1.0` indicates that the radius of the neuron at this location has not been measured.

Nodes are sorted topologically so that a node&#39;s parent is guaranteed to appear before it in the table.

### `*/tags.json`

A JSON file mapping tags (text labels) to the set of nodes (as integer IDs) to which they are applied.

### `*/connectors.tsv`

A tab separated value file with columns
`node_id` (int), `connector_id` (int), `is_input` (boolean as `0`/`1`), `x`, `y`, `z` (all decimal).
The `node_id` refers to rows of `nodes.tsv`.
`connector_id` is consistent among other neurons in this dataset (although not necessarily with other datasets).
`is_input` represents whether the synapse is an output/ presynapse (`0`) or input/ postsynapse (`1`).

By comparing the `connector_id` and `is_input` of `connectors.tsv` files between neurons, you can determine synaptic partners.
However, not all partners are guaranteed to be in this dataset.

### `*/metadata.json`

A JSON file with miscellaneous data about the neuron, including:

- `&#34;name&#34;`: name of the neuron
- `&#34;id&#34;`: integer ID of the neuron
- `&#34;soma_id&#34;`: integer ID of the neuron&#39;s soma (`null` if not labeled)
- `&#34;annotations&#34;`: list of string labels applied to the neuron
&#34;&#34;&#34;.lstrip()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="catmaid_publish.skeletons.filter_tags"><code class="name flex">
<span>def <span class="ident">filter_tags</span></span>(<span>tags: dict[str, list[int]], names: Optional[list[str]], rename: dict[str, str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_tags(
    tags: dict[str, list[int]], names: Optional[list[str]], rename: dict[str, str]
):
    if names is None:
        rename = fill_in_dict(rename, list(tags))
    else:
        rename = fill_in_dict(rename, names)

    return {rename[k]: sorted(v) for k, v in tags.items() if k in rename}</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.fn_or_none"><code class="name flex">
<span>def <span class="ident">fn_or_none</span></span>(<span>item, fn)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fn_or_none(item, fn):
    if item is None:
        return None
    return fn(item)</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.get_all_skids"><code class="name flex">
<span>def <span class="ident">get_all_skids</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_skids():
    try:
        # once https://github.com/navis-org/pymaid/pull/227 is released
        return pymaid.get_skeleton_ids()
    except ImportError:
        pass

    cm = pymaid.utils._eval_remote_instance(None)
    url = cm.make_url(
        cm.project_id,
        &#34;skeletons&#34;,
    )
    return set(cm.fetch(url))</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.get_renamed_annotations"><code class="name flex">
<span>def <span class="ident">get_renamed_annotations</span></span>(<span>nrn: pymaid.core.CatmaidNeuron, rename: dict[str, str]) ‑> set[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_renamed_annotations(
    nrn: pymaid.CatmaidNeuron, rename: dict[str, str]
) -&gt; set[str]:
    anns = nrn.get_annotations()
    return {rename[a] for a in anns if a in rename}</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.get_skeletons"><code class="name flex">
<span>def <span class="ident">get_skeletons</span></span>(<span>annotated: list[str], names: Optional[list[str]], rename: dict[str, str], tag_names: Optional[list[str]], tag_rename: dict[str, str], annotations_rename: dict[str, str]) ‑> collections.abc.Iterable[tuple[pymaid.core.CatmaidNeuron, dict[str, typing.Any]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_skeletons(
    annotated: list[str],
    names: Optional[list[str]],
    rename: dict[str, str],
    tag_names: Optional[list[str]],
    tag_rename: dict[str, str],
    annotations_rename: dict[str, str],
) -&gt; Iterable[tuple[pymaid.CatmaidNeuron, dict[str, Any]]]:
    if names is None:
        skids = get_all_skids()
    else:
        skids = set()
        if names:
            skids.update(pymaid.get_skids_by_name(names))
        if rename:
            skids.update(pymaid.get_skids_by_name(list(rename)))
        if annotated:
            all_anns = sub_annotations(annotated)
            skids.update(pymaid.get_skids_by_annotation(all_anns))

    logger.warning(&#34;Fetching %s skeletons, may be slow&#34;, len(skids))
    neurons: pymaid.CatmaidNeuronList = pymaid.get_neuron(sorted(skids))

    nrn: pymaid.CatmaidNeuron
    for nrn in tqdm(neurons, desc=&#34;Finalising neurons&#34;):
        nrn.name = rename.get(nrn.name, nrn.name)
        nrn.tags = filter_tags(nrn.tags, tag_names, tag_rename)
        anns = get_renamed_annotations(nrn, annotations_rename)
        meta = {
            &#34;name&#34;: fn_or_none(nrn.name, str),
            &#34;skeleton_id&#34;: int(nrn.id),
            &#34;soma_id&#34;: fn_or_none(nrn.soma, int),
            &#34;annotations&#34;: sorted(anns),
        }
        yield nrn, meta</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.sort_skel_dfs"><code class="name flex">
<span>def <span class="ident">sort_skel_dfs</span></span>(<span>df: pandas.core.frame.DataFrame, roots, sort_children=True, inplace=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Depth-first search tree to ensure parents are always defined before children.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_skel_dfs(df: pd.DataFrame, roots, sort_children=True, inplace=False):
    &#34;&#34;&#34;Depth-first search tree to ensure parents are always defined before children.&#34;&#34;&#34;
    children = defaultdict(list)
    node_id_to_orig_idx = dict()
    for row in df.itertuples():
        child = row.node_id
        parent = row.parent_id
        children[parent].append(child)
        node_id_to_orig_idx[child] = row.Index

    if sort_children:
        to_visit = sorted(roots, reverse=True)
    else:
        to_visit = list(roots)[::-1]

    order = np.full(len(df), np.nan)
    count = 0
    while to_visit:
        node_id = to_visit.pop()
        order[node_id_to_orig_idx[node_id]] = count
        cs = children.pop(order[-1], [])
        if sort_children:
            to_visit.extend(sorted(cs, reverse=True))
        else:
            to_visit.extend(cs[::-1])
        count += 1

    # undefined behaviour if any nodes are not reachable from the given roots

    if not inplace:
        df = df.copy()

    df[&#34;_order&#34;] = order
    df.sort_values(&#34;_order&#34;, inplace=True)
    df.drop(columns=[&#34;_order&#34;], inplace=True)
    return df</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.sub_annotations"><code class="name flex">
<span>def <span class="ident">sub_annotations</span></span>(<span>ann_names: list[str])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sub_annotations(ann_names: list[str]):
    g = entity_graph()
    an = set(ann_names)
    ann_ids = descendants(
        g,
        [
            n
            for n, d in g.nodes(data=True)
            if d[&#34;type&#34;] == &#34;annotation&#34; and d[&#34;name&#34;] in an
        ],
        select_fn=(lambda n, d: d[&#34;type&#34;] == &#34;annotation&#34;),
    )
    return [g.nodes[a][&#34;name&#34;] for a in ann_ids]</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.write_skeleton"><code class="name flex">
<span>def <span class="ident">write_skeleton</span></span>(<span>dpath: pathlib.Path, nrn: pymaid.core.CatmaidNeuron, meta: dict[str, typing.Any])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_skeleton(dpath: Path, nrn: pymaid.CatmaidNeuron, meta: dict[str, Any]):
    dpath.mkdir(parents=True)

    with open(dpath / &#34;metadata.json&#34;, &#34;w&#34;) as f:
        json.dump(meta, f, indent=2, sort_keys=True)

    with open(dpath / &#34;tags.json&#34;, &#34;w&#34;) as f:
        json.dump(nrn.tags, f, sort_keys=True, indent=2)

    nodes = sort_skel_dfs(
        nrn.nodes[[&#34;node_id&#34;, &#34;parent_id&#34;, &#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;radius&#34;]],
        nrn.root,
    )
    nodes.to_csv(dpath / &#34;nodes.tsv&#34;, sep=&#34;\t&#34;, index=False)

    conns = nrn.connectors.sort_values(&#34;node_id&#34;, inplace=False)
    conns.rename(columns={&#34;type&#34;: &#34;is_input&#34;}, inplace=True)
    conns.to_csv(dpath / &#34;connectors.tsv&#34;, sep=&#34;\t&#34;, index=False)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="catmaid_publish.skeletons.ReadSpec"><code class="flex name class">
<span>class <span class="ident">ReadSpec</span></span>
<span>(</span><span>nodes: bool = True, connectors: bool = True, tags: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify a subset of a skeleton's data to read.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadSpec(NamedTuple):
    &#34;&#34;&#34;Specify a subset of a skeleton&#39;s data to read.&#34;&#34;&#34;

    nodes: bool = True
    connectors: bool = True
    tags: bool = True

    def copy(self, nodes=None, connectors=None, tags=None):
        return type(self)(
            nodes=nodes if nodes is not None else self.nodes,
            connectors=connectors if connectors is not None else self.connectors,
            tags=tags if tags is not None else self.tags,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="catmaid_publish.skeletons.ReadSpec.connectors"><code class="name">var <span class="ident">connectors</span> : bool</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="catmaid_publish.skeletons.ReadSpec.nodes"><code class="name">var <span class="ident">nodes</span> : bool</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="catmaid_publish.skeletons.ReadSpec.tags"><code class="name">var <span class="ident">tags</span> : bool</code></dt>
<dd>
<div class="desc"><p>Alias for field number 2</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="catmaid_publish.skeletons.ReadSpec.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, nodes=None, connectors=None, tags=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, nodes=None, connectors=None, tags=None):
    return type(self)(
        nodes=nodes if nodes is not None else self.nodes,
        connectors=connectors if connectors is not None else self.connectors,
        tags=tags if tags is not None else self.tags,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="catmaid_publish.skeletons.SkeletonReader"><code class="flex name class">
<span>class <span class="ident">SkeletonReader</span></span>
<span>(</span><span>dpath: pathlib.Path, units=None, read_spec=ReadSpec(nodes=True, connectors=True, tags=True))</span>
</code></dt>
<dd>
<div class="desc"><p>Class for reading exported skeletonised neuron data.</p>
<p>Most "get_" methods take a <code>read_spec</code> argument.
This is a 3-(named)tuple of bools representing
whether to populate the nodes, connectors, and tags fields
of the returned TreeNeuron objects.
By default, all will be populated.
Metadata is always populated.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dpath</code></strong> :&ensp;<code>Path</code></dt>
<dd>Directory in which the neuron data is saved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SkeletonReader:
    &#34;&#34;&#34;Class for reading exported skeletonised neuron data.

    Most &#34;get_&#34; methods take a ``read_spec`` argument.
    This is a 3-(named)tuple of bools representing
    whether to populate the nodes, connectors, and tags fields
    of the returned TreeNeuron objects.
    By default, all will be populated.
    Metadata is always populated.
    &#34;&#34;&#34;

    def __init__(self, dpath: Path, units=None, read_spec=ReadSpec()) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        dpath : Path
            Directory in which the neuron data is saved.
        &#34;&#34;&#34;
        self.dpath = dpath
        self.units = units
        self.default_read_spec = ReadSpec(*read_spec)

    @copy_cache(maxsize=CACHE_SIZE)
    def _read_meta(self, dpath):
        return json.loads((dpath / &#34;metadata.json&#34;).read_text())

    @copy_cache(maxsize=CACHE_SIZE)
    def _read_nodes(self, dpath):
        return pd.read_csv(dpath / &#34;nodes.tsv&#34;, sep=&#34;\t&#34;)

    @copy_cache(maxsize=CACHE_SIZE)
    def _read_tags(self, dpath):
        return json.loads((dpath / &#34;tags.json&#34;).read_text())

    @copy_cache(maxsize=CACHE_SIZE)
    def _read_connectors(self, dpath):
        conns = pd.read_csv(dpath / &#34;connectors.tsv&#34;, sep=&#34;\t&#34;)
        conns.rename(columns={&#34;is_input&#34;: &#34;type&#34;}, inplace=True)
        return conns

    def parse_read_spec(self, read_spec: Optional[Sequence[bool]] = None) -&gt; ReadSpec:
        if read_spec is None:
            read_spec = self.default_read_spec
        else:
            read_spec = ReadSpec(*read_spec)
        return read_spec

    def _construct_neuron(self, meta, nodes=None, tags=None, connectors=None):
        nrn = navis.TreeNeuron(nodes, self.units, annotations=meta[&#34;annotations&#34;])
        nrn.id = meta[&#34;id&#34;]
        nrn.name = meta[&#34;name&#34;]
        nrn.soma = meta[&#34;soma_id&#34;]

        nrn.tags = tags
        nrn.connectors = connectors
        return nrn

    def _read_neuron(
        self, dpath, read_spec: Optional[ReadSpec] = None
    ) -&gt; navis.TreeNeuron:
        read_spec = self.parse_read_spec(read_spec)

        meta = self._read_meta(dpath)

        if read_spec.nodes:
            nodes = self._read_nodes(dpath)
        else:
            nodes = None

        if read_spec.tags:
            tags = self._read_tags(dpath)
        else:
            tags = None

        if read_spec.connectors:
            connectors = self._read_connectors(dpath)
        else:
            connectors = None

        return self._construct_neuron(meta, nodes, tags, connectors)

    def get_by_id(
        self, skeleton_id: int, read_spec: Optional[ReadSpec] = None
    ) -&gt; navis.TreeNeuron:
        &#34;&#34;&#34;Read neuron with the given skeleton ID.

        Parameters
        ----------
        skeleton_id : int

        Returns
        -------
        navis.TreeNeuron
        &#34;&#34;&#34;
        return self._read_neuron(self.dpath / str(skeleton_id), read_spec)

    def _iter_dirs(self):
        for path in self.dpath.iterdir():
            if path.is_dir():
                yield path

    @lru_cache
    def name_to_id(self) -&gt; dict[str, int]:
        &#34;&#34;&#34;Mapping from neuron name to skeleton ID.

        Returns
        -------
        dict[str, int]
        &#34;&#34;&#34;
        out = dict()

        for dpath in self._iter_dirs():
            meta = self._read_meta(dpath)
            out[meta[&#34;name&#34;]] = meta[&#34;id&#34;]

        return out

    @lru_cache
    def annotation_to_ids(self) -&gt; dict[str, list[int]]:
        &#34;&#34;&#34;Which skeletons string annotations are applied to.

        Returns
        -------
        dict[str, list[int]]
            Mapping from annotation name to list of skeleton IDs.
        &#34;&#34;&#34;
        out: dict[str, list[int]] = dict()

        for dpath in self._iter_dirs():
            meta = self._read_meta(dpath)
            for ann in meta[&#34;annotations&#34;]:
                out.setdefault(ann, []).append(meta[&#34;id&#34;])

        return out

    def get_by_name(
        self, name: str, read_spec: Optional[ReadSpec] = None
    ) -&gt; navis.TreeNeuron:
        &#34;&#34;&#34;Read neuron with the given name.

        Parameters
        ----------
        name : str
            Exact neuron name.

        Returns
        -------
        navis.TreeNeuron
        &#34;&#34;&#34;
        d = self.name_to_id()
        return self.get_by_id(d[name], read_spec)

    def get_by_annotation(
        self, annotation: str, read_spec: Optional[ReadSpec] = None
    ) -&gt; Iterable[navis.TreeNeuron]:
        &#34;&#34;&#34;Lazily iterate through neurons with the given annotation.

        Parameters
        ----------
        annotation : str
            Exact annotation.

        Yields
        ------
        navis.TreeNeuron
        &#34;&#34;&#34;
        d = self.annotation_to_ids()
        for skid in d[annotation]:
            yield self.get_by_id(skid, read_spec)

    def get_annotation_names(self) -&gt; set[str]:
        &#34;&#34;&#34;Return all annotations represented in the dataset.

        Returns
        -------
        set[str]
            Set of annotation names.
        &#34;&#34;&#34;
        d = self.annotation_to_ids()
        return set(d)

    def get_annotation_graph(self) -&gt; nx.DiGraph:
        &#34;&#34;&#34;Return graph of neuron annotations.

        Returns
        -------
        nx.DiGraph
            Edges are from annotations to neuron names.
            All nodes have attribute ``&#34;type&#34;``,
            which is either ``&#34;neuron&#34;`` or ``&#34;annotation&#34;``.
            All edges have attribute ``&#34;meta_annotation&#34;=False``.
        &#34;&#34;&#34;
        g = nx.DiGraph()
        anns = set()
        neurons = set()
        for dpath in self._iter_dirs():
            meta = self._read_meta(dpath)
            name = meta[&#34;name&#34;]
            neurons.add(name)
            for ann in meta[&#34;annotations&#34;]:
                anns.add(ann)
                g.add_edge(ann, name, meta_annotation=False)

        ann_data = {&#34;type&#34;: &#34;annotation&#34;}
        for ann in anns:
            g.nodes[ann].update(ann_data)

        return g

    def get_all(
        self, read_spec: Optional[ReadSpec] = None
    ) -&gt; Iterable[navis.TreeNeuron]:
        &#34;&#34;&#34;Lazily iterate through neurons in arbitrary order.

        Can be used for filtering neurons based on some metadata, e.g.

            lefts = []
            for nrn in my_reader.get_all(ReadSpec(False, False, False)):
                if &#34;left&#34; in nrn.name:
                    lefts.append(my_reader.get_by_id(nrn.id)))

        Yields
        ------
        navis.TreeNeuron
        &#34;&#34;&#34;
        for dpath in self._iter_dirs():
            yield self._read_neuron(dpath, read_spec)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="catmaid_publish.skeletons.SkeletonReader.annotation_to_ids"><code class="name flex">
<span>def <span class="ident">annotation_to_ids</span></span>(<span>self) ‑> dict[str, list[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Which skeletons string annotations are applied to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, list[int]]</code></dt>
<dd>Mapping from annotation name to list of skeleton IDs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@lru_cache
def annotation_to_ids(self) -&gt; dict[str, list[int]]:
    &#34;&#34;&#34;Which skeletons string annotations are applied to.

    Returns
    -------
    dict[str, list[int]]
        Mapping from annotation name to list of skeleton IDs.
    &#34;&#34;&#34;
    out: dict[str, list[int]] = dict()

    for dpath in self._iter_dirs():
        meta = self._read_meta(dpath)
        for ann in meta[&#34;annotations&#34;]:
            out.setdefault(ann, []).append(meta[&#34;id&#34;])

    return out</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.SkeletonReader.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>self, read_spec: Optional[<a title="catmaid_publish.skeletons.ReadSpec" href="#catmaid_publish.skeletons.ReadSpec">ReadSpec</a>] = None) ‑> collections.abc.Iterable[navis.core.skeleton.TreeNeuron]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily iterate through neurons in arbitrary order.</p>
<p>Can be used for filtering neurons based on some metadata, e.g.</p>
<pre><code>lefts = []
for nrn in my_reader.get_all(ReadSpec(False, False, False)):
    if "left" in nrn.name:
        lefts.append(my_reader.get_by_id(nrn.id)))
</code></pre>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>navis.TreeNeuron</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(
    self, read_spec: Optional[ReadSpec] = None
) -&gt; Iterable[navis.TreeNeuron]:
    &#34;&#34;&#34;Lazily iterate through neurons in arbitrary order.

    Can be used for filtering neurons based on some metadata, e.g.

        lefts = []
        for nrn in my_reader.get_all(ReadSpec(False, False, False)):
            if &#34;left&#34; in nrn.name:
                lefts.append(my_reader.get_by_id(nrn.id)))

    Yields
    ------
    navis.TreeNeuron
    &#34;&#34;&#34;
    for dpath in self._iter_dirs():
        yield self._read_neuron(dpath, read_spec)</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.SkeletonReader.get_annotation_graph"><code class="name flex">
<span>def <span class="ident">get_annotation_graph</span></span>(<span>self) ‑> networkx.classes.digraph.DiGraph</span>
</code></dt>
<dd>
<div class="desc"><p>Return graph of neuron annotations.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>nx.DiGraph</code></dt>
<dd>Edges are from annotations to neuron names.
All nodes have attribute <code>"type"</code>,
which is either <code>"neuron"</code> or <code>"annotation"</code>.
All edges have attribute <code>"meta_annotation"=False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotation_graph(self) -&gt; nx.DiGraph:
    &#34;&#34;&#34;Return graph of neuron annotations.

    Returns
    -------
    nx.DiGraph
        Edges are from annotations to neuron names.
        All nodes have attribute ``&#34;type&#34;``,
        which is either ``&#34;neuron&#34;`` or ``&#34;annotation&#34;``.
        All edges have attribute ``&#34;meta_annotation&#34;=False``.
    &#34;&#34;&#34;
    g = nx.DiGraph()
    anns = set()
    neurons = set()
    for dpath in self._iter_dirs():
        meta = self._read_meta(dpath)
        name = meta[&#34;name&#34;]
        neurons.add(name)
        for ann in meta[&#34;annotations&#34;]:
            anns.add(ann)
            g.add_edge(ann, name, meta_annotation=False)

    ann_data = {&#34;type&#34;: &#34;annotation&#34;}
    for ann in anns:
        g.nodes[ann].update(ann_data)

    return g</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.SkeletonReader.get_annotation_names"><code class="name flex">
<span>def <span class="ident">get_annotation_names</span></span>(<span>self) ‑> set[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return all annotations represented in the dataset.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set[str]</code></dt>
<dd>Set of annotation names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_annotation_names(self) -&gt; set[str]:
    &#34;&#34;&#34;Return all annotations represented in the dataset.

    Returns
    -------
    set[str]
        Set of annotation names.
    &#34;&#34;&#34;
    d = self.annotation_to_ids()
    return set(d)</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.SkeletonReader.get_by_annotation"><code class="name flex">
<span>def <span class="ident">get_by_annotation</span></span>(<span>self, annotation: str, read_spec: Optional[<a title="catmaid_publish.skeletons.ReadSpec" href="#catmaid_publish.skeletons.ReadSpec">ReadSpec</a>] = None) ‑> collections.abc.Iterable[navis.core.skeleton.TreeNeuron]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily iterate through neurons with the given annotation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>annotation</code></strong> :&ensp;<code>str</code></dt>
<dd>Exact annotation.</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>navis.TreeNeuron</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_annotation(
    self, annotation: str, read_spec: Optional[ReadSpec] = None
) -&gt; Iterable[navis.TreeNeuron]:
    &#34;&#34;&#34;Lazily iterate through neurons with the given annotation.

    Parameters
    ----------
    annotation : str
        Exact annotation.

    Yields
    ------
    navis.TreeNeuron
    &#34;&#34;&#34;
    d = self.annotation_to_ids()
    for skid in d[annotation]:
        yield self.get_by_id(skid, read_spec)</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.SkeletonReader.get_by_id"><code class="name flex">
<span>def <span class="ident">get_by_id</span></span>(<span>self, skeleton_id: int, read_spec: Optional[<a title="catmaid_publish.skeletons.ReadSpec" href="#catmaid_publish.skeletons.ReadSpec">ReadSpec</a>] = None) ‑> navis.core.skeleton.TreeNeuron</span>
</code></dt>
<dd>
<div class="desc"><p>Read neuron with the given skeleton ID.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>skeleton_id</code></strong> :&ensp;<code>int</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>navis.TreeNeuron</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_id(
    self, skeleton_id: int, read_spec: Optional[ReadSpec] = None
) -&gt; navis.TreeNeuron:
    &#34;&#34;&#34;Read neuron with the given skeleton ID.

    Parameters
    ----------
    skeleton_id : int

    Returns
    -------
    navis.TreeNeuron
    &#34;&#34;&#34;
    return self._read_neuron(self.dpath / str(skeleton_id), read_spec)</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.SkeletonReader.get_by_name"><code class="name flex">
<span>def <span class="ident">get_by_name</span></span>(<span>self, name: str, read_spec: Optional[<a title="catmaid_publish.skeletons.ReadSpec" href="#catmaid_publish.skeletons.ReadSpec">ReadSpec</a>] = None) ‑> navis.core.skeleton.TreeNeuron</span>
</code></dt>
<dd>
<div class="desc"><p>Read neuron with the given name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Exact neuron name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>navis.TreeNeuron</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_by_name(
    self, name: str, read_spec: Optional[ReadSpec] = None
) -&gt; navis.TreeNeuron:
    &#34;&#34;&#34;Read neuron with the given name.

    Parameters
    ----------
    name : str
        Exact neuron name.

    Returns
    -------
    navis.TreeNeuron
    &#34;&#34;&#34;
    d = self.name_to_id()
    return self.get_by_id(d[name], read_spec)</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.SkeletonReader.name_to_id"><code class="name flex">
<span>def <span class="ident">name_to_id</span></span>(<span>self) ‑> dict[str, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Mapping from neuron name to skeleton ID.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, int]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@lru_cache
def name_to_id(self) -&gt; dict[str, int]:
    &#34;&#34;&#34;Mapping from neuron name to skeleton ID.

    Returns
    -------
    dict[str, int]
    &#34;&#34;&#34;
    out = dict()

    for dpath in self._iter_dirs():
        meta = self._read_meta(dpath)
        out[meta[&#34;name&#34;]] = meta[&#34;id&#34;]

    return out</code></pre>
</details>
</dd>
<dt id="catmaid_publish.skeletons.SkeletonReader.parse_read_spec"><code class="name flex">
<span>def <span class="ident">parse_read_spec</span></span>(<span>self, read_spec: Optional[Sequence[bool]] = None) ‑> <a title="catmaid_publish.skeletons.ReadSpec" href="#catmaid_publish.skeletons.ReadSpec">ReadSpec</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_read_spec(self, read_spec: Optional[Sequence[bool]] = None) -&gt; ReadSpec:
    if read_spec is None:
        read_spec = self.default_read_spec
    else:
        read_spec = ReadSpec(*read_spec)
    return read_spec</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="catmaid_publish" href="index.html">catmaid_publish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="catmaid_publish.skeletons.filter_tags" href="#catmaid_publish.skeletons.filter_tags">filter_tags</a></code></li>
<li><code><a title="catmaid_publish.skeletons.fn_or_none" href="#catmaid_publish.skeletons.fn_or_none">fn_or_none</a></code></li>
<li><code><a title="catmaid_publish.skeletons.get_all_skids" href="#catmaid_publish.skeletons.get_all_skids">get_all_skids</a></code></li>
<li><code><a title="catmaid_publish.skeletons.get_renamed_annotations" href="#catmaid_publish.skeletons.get_renamed_annotations">get_renamed_annotations</a></code></li>
<li><code><a title="catmaid_publish.skeletons.get_skeletons" href="#catmaid_publish.skeletons.get_skeletons">get_skeletons</a></code></li>
<li><code><a title="catmaid_publish.skeletons.sort_skel_dfs" href="#catmaid_publish.skeletons.sort_skel_dfs">sort_skel_dfs</a></code></li>
<li><code><a title="catmaid_publish.skeletons.sub_annotations" href="#catmaid_publish.skeletons.sub_annotations">sub_annotations</a></code></li>
<li><code><a title="catmaid_publish.skeletons.write_skeleton" href="#catmaid_publish.skeletons.write_skeleton">write_skeleton</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="catmaid_publish.skeletons.ReadSpec" href="#catmaid_publish.skeletons.ReadSpec">ReadSpec</a></code></h4>
<ul class="">
<li><code><a title="catmaid_publish.skeletons.ReadSpec.connectors" href="#catmaid_publish.skeletons.ReadSpec.connectors">connectors</a></code></li>
<li><code><a title="catmaid_publish.skeletons.ReadSpec.copy" href="#catmaid_publish.skeletons.ReadSpec.copy">copy</a></code></li>
<li><code><a title="catmaid_publish.skeletons.ReadSpec.nodes" href="#catmaid_publish.skeletons.ReadSpec.nodes">nodes</a></code></li>
<li><code><a title="catmaid_publish.skeletons.ReadSpec.tags" href="#catmaid_publish.skeletons.ReadSpec.tags">tags</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="catmaid_publish.skeletons.SkeletonReader" href="#catmaid_publish.skeletons.SkeletonReader">SkeletonReader</a></code></h4>
<ul class="">
<li><code><a title="catmaid_publish.skeletons.SkeletonReader.annotation_to_ids" href="#catmaid_publish.skeletons.SkeletonReader.annotation_to_ids">annotation_to_ids</a></code></li>
<li><code><a title="catmaid_publish.skeletons.SkeletonReader.get_all" href="#catmaid_publish.skeletons.SkeletonReader.get_all">get_all</a></code></li>
<li><code><a title="catmaid_publish.skeletons.SkeletonReader.get_annotation_graph" href="#catmaid_publish.skeletons.SkeletonReader.get_annotation_graph">get_annotation_graph</a></code></li>
<li><code><a title="catmaid_publish.skeletons.SkeletonReader.get_annotation_names" href="#catmaid_publish.skeletons.SkeletonReader.get_annotation_names">get_annotation_names</a></code></li>
<li><code><a title="catmaid_publish.skeletons.SkeletonReader.get_by_annotation" href="#catmaid_publish.skeletons.SkeletonReader.get_by_annotation">get_by_annotation</a></code></li>
<li><code><a title="catmaid_publish.skeletons.SkeletonReader.get_by_id" href="#catmaid_publish.skeletons.SkeletonReader.get_by_id">get_by_id</a></code></li>
<li><code><a title="catmaid_publish.skeletons.SkeletonReader.get_by_name" href="#catmaid_publish.skeletons.SkeletonReader.get_by_name">get_by_name</a></code></li>
<li><code><a title="catmaid_publish.skeletons.SkeletonReader.name_to_id" href="#catmaid_publish.skeletons.SkeletonReader.name_to_id">name_to_id</a></code></li>
<li><code><a title="catmaid_publish.skeletons.SkeletonReader.parse_read_spec" href="#catmaid_publish.skeletons.SkeletonReader.parse_read_spec">parse_read_spec</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>