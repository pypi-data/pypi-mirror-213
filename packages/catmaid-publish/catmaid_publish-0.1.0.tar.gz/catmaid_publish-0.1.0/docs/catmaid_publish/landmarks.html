<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>catmaid_publish.landmarks API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>catmaid_publish.landmarks</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

import json
from dataclasses import asdict, dataclass, field
from pathlib import Path
from typing import Any, Iterable, Optional

import pandas as pd
import pymaid

from .utils import copy_cache, fill_in_dict


def get_landmarks(
    groups: Optional[list[str]],
    group_rename: dict[str, str],
    names: Optional[list[str]],
    rename: dict[str, str],
) -&gt; tuple[pd.DataFrame, pd.DataFrame]:
    &#34;&#34;&#34;Get locations associated with landmarks and groups.

    Parameters
    ----------
    groups : Optional[list[str]]
        List of group names of interest (None means all)
    group_rename : dict[str, str]
        Remap group names.
    names : Optional[list[str]]
        List of landmark names of interest(None means all)
    rename : dict[str, str]
        Remap landmark names.

    Returns
    -------
    tuple[pd.DataFrame, pd.DataFrame]
        Dataframes have columns location_id, x, y, z, name.

        The first element refers to landmarks, the second to groups.
        Locations are not unique as they can belong to several landmarks and/or groups.
    &#34;&#34;&#34;
    lmark_df, lmark_loc_df = pymaid.get_landmarks()

    if names is None:
        names = list(lmark_df[&#34;name&#34;])
    rename = fill_in_dict(rename, names)

    # location_id, x, y, z, landmark_id
    # landmark_id, name, user_id, project_id, creation_time, edition_time
    lmark_combined = lmark_loc_df.merge(lmark_df, on=&#34;landmark_id&#34;)
    lmark_reduced = lmark_combined.loc[lmark_combined[&#34;name&#34;].isin(rename)].copy()
    lmark_reduced[&#34;name&#34;] = [rename[old] for old in lmark_reduced[&#34;name&#34;]]
    lmark_final = lmark_reduced.drop(
        columns=[
            &#34;landmark_id&#34;,
            &#34;user_id&#34;,
            &#34;project_id&#34;,
            &#34;creation_time&#34;,
            &#34;edition_time&#34;,
        ],
        inplace=False,
    )

    group_df, group_loc_df, _ = pymaid.get_landmark_groups(True, False)

    if groups is None:
        groups = list(group_df[&#34;name&#34;])
    group_rename = fill_in_dict(group_rename, groups)

    # location_id, x, y, z, group_id
    # group_id, name, user_id, project_id, creation_time, edition_time.
    group_combined = group_loc_df.merge(group_df, on=&#34;group_id&#34;)
    group_reduced = group_combined.loc[group_combined[&#34;name&#34;].isin(group_rename)].copy()
    group_reduced[&#34;name&#34;] = [group_rename[old] for old in group_reduced[&#34;name&#34;]]

    group_final = group_reduced.drop(
        columns=[&#34;group_id&#34;, &#34;user_id&#34;, &#34;project_id&#34;, &#34;creation_time&#34;, &#34;edition_time&#34;],
        inplace=False,
    )

    return lmark_final, group_final


@dataclass
class Location:
    &#34;&#34;&#34;Location of importance to landmarks and groups.

    Attributes
    ----------
    xyz : tuple[float, float, float]
        Coordinates of location
    groups : set[str]
        Set of landmark groups this location belongs to.
    landmarks : set[str]
        Set of landmarks this location belongs to.
    &#34;&#34;&#34;

    xyz: tuple[float, float, float]
    groups: set[str] = field(default_factory=set)
    landmarks: set[str] = field(default_factory=set)

    def to_jso(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Convert to JSON-serialisable object.

        Returns
        -------
        dict[str, Any]
        &#34;&#34;&#34;
        d = asdict(self)
        d[&#34;xyz&#34;] = list(d[&#34;xyz&#34;])
        d[&#34;groups&#34;] = sorted(d[&#34;groups&#34;])
        d[&#34;landmarks&#34;] = sorted(d[&#34;landmarks&#34;])
        return d

    @classmethod
    def from_jso(cls, jso: dict[str, Any]) -&gt; Location:
        &#34;&#34;&#34;Instantiate from JSON-like dict.

        Parameters
        ----------
        jso : dict[str, Any]
            Keys ``&#34;xyz&#34;`` (3-length list of float),
            ``&#34;groups&#34;`` (list of str),
            ``&#34;landmarks&#34;`` (list of str)

        Returns
        -------
        Location
        &#34;&#34;&#34;
        return cls(
            tuple(jso[&#34;xyz&#34;]),
            set(jso[&#34;groups&#34;]),
            set(jso[&#34;landmarks&#34;]),
        )


def write_landmarks(fpath: Path, landmarks: pd.DataFrame, groups: pd.DataFrame):
    if len(landmarks) + len(groups) == 0:
        return

    location_data: dict[int, Location] = dict()
    for row in landmarks.itertuples(index=False):
        d = location_data.setdefault(row.location_id, Location((row.x, row.y, row.z)))
        d.landmarks.add(row.name)

    for row in groups.itertuples(index=False):
        d = location_data.setdefault(row.location_id, Location((row.x, row.y, row.z)))
        d.groups.add(row.name)

    out = [v.to_jso() for _, v in sorted(location_data.items())]

    with open(fpath, &#34;w&#34;) as f:
        json.dump(out, f, indent=2, sort_keys=True)


class LandmarkReader:
    &#34;&#34;&#34;Class for reading exported landmark data.&#34;&#34;&#34;

    def __init__(self, dpath: Path) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        dpath : Path
            Directory in which landmark data is saved.
        &#34;&#34;&#34;
        self.dpath = dpath
        self.fpath = dpath / &#34;locations.json&#34;

    @copy_cache()
    def _locations(self):
        with open(self.fpath) as f:
            d = json.load(f)

        return [Location.from_jso(loc) for loc in d]

    def get_all(self) -&gt; Iterable[Location]:
        &#34;&#34;&#34;Lazily iterate through landmark locations.

        Yields
        ------
        Location
        &#34;&#34;&#34;
        yield from self._locations()

    def get_group_names(self) -&gt; set[str]:
        &#34;&#34;&#34;Return all groups with locations in the dataset.

        Returns
        -------
        set[str]
            Set of group names.
        &#34;&#34;&#34;
        out = set()
        for loc in self._locations():
            out.update(loc.groups)
        return out

    def get_landmark_names(self) -&gt; set[str]:
        &#34;&#34;&#34;Return all landmarks with locations in the dataset.

        Returns
        -------
        set[str]
            Set of landmark names.
        &#34;&#34;&#34;
        out = set()
        for loc in self._locations():
            out.update(loc.landmarks)
        return out

    def get_group(self, *group: str) -&gt; Iterable[Location]:
        &#34;&#34;&#34;Lazily iterate through all locations from any of the given groups.

        Parameters
        ----------
        group : str
            Group name (can give multiple as *args).

        Yields
        ------
        Location
        &#34;&#34;&#34;
        groupset = set(group)
        for loc in self._locations():
            if not loc.groups.isdisjoint(groupset):
                yield loc

    def get_landmark(self, *landmark: str) -&gt; Iterable[Location]:
        &#34;&#34;&#34;Lazily iterate through all locations from any of the given landmarks.

        Parameters
        ----------
        landmark : str
            Landmark name (can give multiple as *args)

        Yields
        ------
        Location
        &#34;&#34;&#34;
        lmarkset = set(landmark)
        for loc in self._locations():
            if not loc.landmarks.isdisjoint(lmarkset):
                yield loc

    def get_paired_locations(
        self, group1: str, group2: str
    ) -&gt; Iterable[tuple[Location, Location]]:
        &#34;&#34;&#34;Iterate through paired locations.

        Locations are paired when both belong to the same landmark,
        and each location is the only one of that landmark to exist in that group,
        and they are not the same location.

        This is useful for creating transformations between two spaces
        (as landmark groups) by shared features (as landmarks).

        Parameters
        ----------
        group1 : str
            Group name
        group2 : str
            Group name

        Yields
        ------
        tuple[Location, Location]
        &#34;&#34;&#34;
        la_lo1: dict[str, list[Location]] = dict()
        la_lo2: dict[str, list[Location]] = dict()
        for loc in self._locations():
            if group1 in loc.groups:
                if group2 in loc.groups:
                    continue
                for landmark in loc.landmarks:
                    la_lo1.setdefault(landmark, []).append(loc)
            elif group2 in loc.groups:
                for landmark in loc.landmarks:
                    la_lo2.setdefault(landmark, []).append(loc)

        landmarks = sorted(set(la_lo1).intersection(la_lo2))
        for la in landmarks:
            lo1 = la_lo1[la]
            if len(lo1) != 1:
                continue
            lo2 = la_lo2[la]
            if len(lo2) != 1:
                continue

            yield lo1[0], lo2[0]


README = &#34;&#34;&#34;
# Landmarks

Landmarks represent important points in space.
A *landmark* can have multiple *locations* associated with it:
for example, one landmark can represent a neuron lineage entry point which exists on both sides of the central nervous system, or is segmentally repeated.

A landmark *group* is a collection of *landmark*s.
For example, a landmark group can represent all neuron lineage entry points in the brain.
However, not all of a *landmark*&#39;s *location*s are necessarily associated with a *group* even if the group includes that *landmark*.
This allows for *landmark*/ *group* intersections like:

- landmark: bilateral pair of homologous neuron lineage **A** entry points
- group: all neuron lineage entry points on the **left** side of the brain

Data in this directory can be parsed into sets of `catmaid_publish.Location` objects
(which contain coordinates and landmark/group memberships)
using `catmaid_publish.LandmarkReader`.

## Files

### `locations.json`

A JSON file which is an array of objects representing locations of interest.

Each object&#39;s keys are:

- `&#34;landmarks&#34;`: array of names of landmarks to which this location belongs
- `&#34;groups&#34;`: array of names of landmark groups to which this location belongs
- `&#34;xyz&#34;`: 3-length array of decimals representing coordinates of location
&#34;&#34;&#34;.lstrip()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="catmaid_publish.landmarks.get_landmarks"><code class="name flex">
<span>def <span class="ident">get_landmarks</span></span>(<span>groups: Optional[list[str]], group_rename: dict[str, str], names: Optional[list[str]], rename: dict[str, str]) ‑> tuple[pandas.core.frame.DataFrame, pandas.core.frame.DataFrame]</span>
</code></dt>
<dd>
<div class="desc"><p>Get locations associated with landmarks and groups.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>groups</code></strong> :&ensp;<code>Optional[list[str]]</code></dt>
<dd>List of group names of interest (None means all)</dd>
<dt><strong><code>group_rename</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>Remap group names.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>Optional[list[str]]</code></dt>
<dd>List of landmark names of interest(None means all)</dd>
<dt><strong><code>rename</code></strong> :&ensp;<code>dict[str, str]</code></dt>
<dd>Remap landmark names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[pd.DataFrame, pd.DataFrame]</code></dt>
<dd>
<p>Dataframes have columns location_id, x, y, z, name.</p>
<p>The first element refers to landmarks, the second to groups.
Locations are not unique as they can belong to several landmarks and/or groups.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_landmarks(
    groups: Optional[list[str]],
    group_rename: dict[str, str],
    names: Optional[list[str]],
    rename: dict[str, str],
) -&gt; tuple[pd.DataFrame, pd.DataFrame]:
    &#34;&#34;&#34;Get locations associated with landmarks and groups.

    Parameters
    ----------
    groups : Optional[list[str]]
        List of group names of interest (None means all)
    group_rename : dict[str, str]
        Remap group names.
    names : Optional[list[str]]
        List of landmark names of interest(None means all)
    rename : dict[str, str]
        Remap landmark names.

    Returns
    -------
    tuple[pd.DataFrame, pd.DataFrame]
        Dataframes have columns location_id, x, y, z, name.

        The first element refers to landmarks, the second to groups.
        Locations are not unique as they can belong to several landmarks and/or groups.
    &#34;&#34;&#34;
    lmark_df, lmark_loc_df = pymaid.get_landmarks()

    if names is None:
        names = list(lmark_df[&#34;name&#34;])
    rename = fill_in_dict(rename, names)

    # location_id, x, y, z, landmark_id
    # landmark_id, name, user_id, project_id, creation_time, edition_time
    lmark_combined = lmark_loc_df.merge(lmark_df, on=&#34;landmark_id&#34;)
    lmark_reduced = lmark_combined.loc[lmark_combined[&#34;name&#34;].isin(rename)].copy()
    lmark_reduced[&#34;name&#34;] = [rename[old] for old in lmark_reduced[&#34;name&#34;]]
    lmark_final = lmark_reduced.drop(
        columns=[
            &#34;landmark_id&#34;,
            &#34;user_id&#34;,
            &#34;project_id&#34;,
            &#34;creation_time&#34;,
            &#34;edition_time&#34;,
        ],
        inplace=False,
    )

    group_df, group_loc_df, _ = pymaid.get_landmark_groups(True, False)

    if groups is None:
        groups = list(group_df[&#34;name&#34;])
    group_rename = fill_in_dict(group_rename, groups)

    # location_id, x, y, z, group_id
    # group_id, name, user_id, project_id, creation_time, edition_time.
    group_combined = group_loc_df.merge(group_df, on=&#34;group_id&#34;)
    group_reduced = group_combined.loc[group_combined[&#34;name&#34;].isin(group_rename)].copy()
    group_reduced[&#34;name&#34;] = [group_rename[old] for old in group_reduced[&#34;name&#34;]]

    group_final = group_reduced.drop(
        columns=[&#34;group_id&#34;, &#34;user_id&#34;, &#34;project_id&#34;, &#34;creation_time&#34;, &#34;edition_time&#34;],
        inplace=False,
    )

    return lmark_final, group_final</code></pre>
</details>
</dd>
<dt id="catmaid_publish.landmarks.write_landmarks"><code class="name flex">
<span>def <span class="ident">write_landmarks</span></span>(<span>fpath: Path, landmarks: pd.DataFrame, groups: pd.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_landmarks(fpath: Path, landmarks: pd.DataFrame, groups: pd.DataFrame):
    if len(landmarks) + len(groups) == 0:
        return

    location_data: dict[int, Location] = dict()
    for row in landmarks.itertuples(index=False):
        d = location_data.setdefault(row.location_id, Location((row.x, row.y, row.z)))
        d.landmarks.add(row.name)

    for row in groups.itertuples(index=False):
        d = location_data.setdefault(row.location_id, Location((row.x, row.y, row.z)))
        d.groups.add(row.name)

    out = [v.to_jso() for _, v in sorted(location_data.items())]

    with open(fpath, &#34;w&#34;) as f:
        json.dump(out, f, indent=2, sort_keys=True)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="catmaid_publish.landmarks.LandmarkReader"><code class="flex name class">
<span>class <span class="ident">LandmarkReader</span></span>
<span>(</span><span>dpath: Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for reading exported landmark data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dpath</code></strong> :&ensp;<code>Path</code></dt>
<dd>Directory in which landmark data is saved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LandmarkReader:
    &#34;&#34;&#34;Class for reading exported landmark data.&#34;&#34;&#34;

    def __init__(self, dpath: Path) -&gt; None:
        &#34;&#34;&#34;
        Parameters
        ----------
        dpath : Path
            Directory in which landmark data is saved.
        &#34;&#34;&#34;
        self.dpath = dpath
        self.fpath = dpath / &#34;locations.json&#34;

    @copy_cache()
    def _locations(self):
        with open(self.fpath) as f:
            d = json.load(f)

        return [Location.from_jso(loc) for loc in d]

    def get_all(self) -&gt; Iterable[Location]:
        &#34;&#34;&#34;Lazily iterate through landmark locations.

        Yields
        ------
        Location
        &#34;&#34;&#34;
        yield from self._locations()

    def get_group_names(self) -&gt; set[str]:
        &#34;&#34;&#34;Return all groups with locations in the dataset.

        Returns
        -------
        set[str]
            Set of group names.
        &#34;&#34;&#34;
        out = set()
        for loc in self._locations():
            out.update(loc.groups)
        return out

    def get_landmark_names(self) -&gt; set[str]:
        &#34;&#34;&#34;Return all landmarks with locations in the dataset.

        Returns
        -------
        set[str]
            Set of landmark names.
        &#34;&#34;&#34;
        out = set()
        for loc in self._locations():
            out.update(loc.landmarks)
        return out

    def get_group(self, *group: str) -&gt; Iterable[Location]:
        &#34;&#34;&#34;Lazily iterate through all locations from any of the given groups.

        Parameters
        ----------
        group : str
            Group name (can give multiple as *args).

        Yields
        ------
        Location
        &#34;&#34;&#34;
        groupset = set(group)
        for loc in self._locations():
            if not loc.groups.isdisjoint(groupset):
                yield loc

    def get_landmark(self, *landmark: str) -&gt; Iterable[Location]:
        &#34;&#34;&#34;Lazily iterate through all locations from any of the given landmarks.

        Parameters
        ----------
        landmark : str
            Landmark name (can give multiple as *args)

        Yields
        ------
        Location
        &#34;&#34;&#34;
        lmarkset = set(landmark)
        for loc in self._locations():
            if not loc.landmarks.isdisjoint(lmarkset):
                yield loc

    def get_paired_locations(
        self, group1: str, group2: str
    ) -&gt; Iterable[tuple[Location, Location]]:
        &#34;&#34;&#34;Iterate through paired locations.

        Locations are paired when both belong to the same landmark,
        and each location is the only one of that landmark to exist in that group,
        and they are not the same location.

        This is useful for creating transformations between two spaces
        (as landmark groups) by shared features (as landmarks).

        Parameters
        ----------
        group1 : str
            Group name
        group2 : str
            Group name

        Yields
        ------
        tuple[Location, Location]
        &#34;&#34;&#34;
        la_lo1: dict[str, list[Location]] = dict()
        la_lo2: dict[str, list[Location]] = dict()
        for loc in self._locations():
            if group1 in loc.groups:
                if group2 in loc.groups:
                    continue
                for landmark in loc.landmarks:
                    la_lo1.setdefault(landmark, []).append(loc)
            elif group2 in loc.groups:
                for landmark in loc.landmarks:
                    la_lo2.setdefault(landmark, []).append(loc)

        landmarks = sorted(set(la_lo1).intersection(la_lo2))
        for la in landmarks:
            lo1 = la_lo1[la]
            if len(lo1) != 1:
                continue
            lo2 = la_lo2[la]
            if len(lo2) != 1:
                continue

            yield lo1[0], lo2[0]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="catmaid_publish.landmarks.LandmarkReader.get_all"><code class="name flex">
<span>def <span class="ident">get_all</span></span>(<span>self) ‑> Iterable[<a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily iterate through landmark locations.</p>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all(self) -&gt; Iterable[Location]:
    &#34;&#34;&#34;Lazily iterate through landmark locations.

    Yields
    ------
    Location
    &#34;&#34;&#34;
    yield from self._locations()</code></pre>
</details>
</dd>
<dt id="catmaid_publish.landmarks.LandmarkReader.get_group"><code class="name flex">
<span>def <span class="ident">get_group</span></span>(<span>self, *group: str) ‑> Iterable[<a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily iterate through all locations from any of the given groups.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>group</code></strong> :&ensp;<code>str</code></dt>
<dd>Group name (can give multiple as *args).</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_group(self, *group: str) -&gt; Iterable[Location]:
    &#34;&#34;&#34;Lazily iterate through all locations from any of the given groups.

    Parameters
    ----------
    group : str
        Group name (can give multiple as *args).

    Yields
    ------
    Location
    &#34;&#34;&#34;
    groupset = set(group)
    for loc in self._locations():
        if not loc.groups.isdisjoint(groupset):
            yield loc</code></pre>
</details>
</dd>
<dt id="catmaid_publish.landmarks.LandmarkReader.get_group_names"><code class="name flex">
<span>def <span class="ident">get_group_names</span></span>(<span>self) ‑> set[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return all groups with locations in the dataset.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set[str]</code></dt>
<dd>Set of group names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_group_names(self) -&gt; set[str]:
    &#34;&#34;&#34;Return all groups with locations in the dataset.

    Returns
    -------
    set[str]
        Set of group names.
    &#34;&#34;&#34;
    out = set()
    for loc in self._locations():
        out.update(loc.groups)
    return out</code></pre>
</details>
</dd>
<dt id="catmaid_publish.landmarks.LandmarkReader.get_landmark"><code class="name flex">
<span>def <span class="ident">get_landmark</span></span>(<span>self, *landmark: str) ‑> Iterable[<a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Lazily iterate through all locations from any of the given landmarks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>landmark</code></strong> :&ensp;<code>str</code></dt>
<dd>Landmark name (can give multiple as *args)</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code><a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_landmark(self, *landmark: str) -&gt; Iterable[Location]:
    &#34;&#34;&#34;Lazily iterate through all locations from any of the given landmarks.

    Parameters
    ----------
    landmark : str
        Landmark name (can give multiple as *args)

    Yields
    ------
    Location
    &#34;&#34;&#34;
    lmarkset = set(landmark)
    for loc in self._locations():
        if not loc.landmarks.isdisjoint(lmarkset):
            yield loc</code></pre>
</details>
</dd>
<dt id="catmaid_publish.landmarks.LandmarkReader.get_landmark_names"><code class="name flex">
<span>def <span class="ident">get_landmark_names</span></span>(<span>self) ‑> set[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Return all landmarks with locations in the dataset.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set[str]</code></dt>
<dd>Set of landmark names.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_landmark_names(self) -&gt; set[str]:
    &#34;&#34;&#34;Return all landmarks with locations in the dataset.

    Returns
    -------
    set[str]
        Set of landmark names.
    &#34;&#34;&#34;
    out = set()
    for loc in self._locations():
        out.update(loc.landmarks)
    return out</code></pre>
</details>
</dd>
<dt id="catmaid_publish.landmarks.LandmarkReader.get_paired_locations"><code class="name flex">
<span>def <span class="ident">get_paired_locations</span></span>(<span>self, group1: str, group2: str) ‑> Iterable[tuple[<a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a>, <a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Iterate through paired locations.</p>
<p>Locations are paired when both belong to the same landmark,
and each location is the only one of that landmark to exist in that group,
and they are not the same location.</p>
<p>This is useful for creating transformations between two spaces
(as landmark groups) by shared features (as landmarks).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>group1</code></strong> :&ensp;<code>str</code></dt>
<dd>Group name</dd>
<dt><strong><code>group2</code></strong> :&ensp;<code>str</code></dt>
<dd>Group name</dd>
</dl>
<h2 id="yields">Yields</h2>
<dl>
<dt><code>tuple[<a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a>, <a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_paired_locations(
    self, group1: str, group2: str
) -&gt; Iterable[tuple[Location, Location]]:
    &#34;&#34;&#34;Iterate through paired locations.

    Locations are paired when both belong to the same landmark,
    and each location is the only one of that landmark to exist in that group,
    and they are not the same location.

    This is useful for creating transformations between two spaces
    (as landmark groups) by shared features (as landmarks).

    Parameters
    ----------
    group1 : str
        Group name
    group2 : str
        Group name

    Yields
    ------
    tuple[Location, Location]
    &#34;&#34;&#34;
    la_lo1: dict[str, list[Location]] = dict()
    la_lo2: dict[str, list[Location]] = dict()
    for loc in self._locations():
        if group1 in loc.groups:
            if group2 in loc.groups:
                continue
            for landmark in loc.landmarks:
                la_lo1.setdefault(landmark, []).append(loc)
        elif group2 in loc.groups:
            for landmark in loc.landmarks:
                la_lo2.setdefault(landmark, []).append(loc)

    landmarks = sorted(set(la_lo1).intersection(la_lo2))
    for la in landmarks:
        lo1 = la_lo1[la]
        if len(lo1) != 1:
            continue
        lo2 = la_lo2[la]
        if len(lo2) != 1:
            continue

        yield lo1[0], lo2[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="catmaid_publish.landmarks.Location"><code class="flex name class">
<span>class <span class="ident">Location</span></span>
<span>(</span><span>xyz: tuple[float, float, float], groups: set[str] = &lt;factory&gt;, landmarks: set[str] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Location of importance to landmarks and groups.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>xyz</code></strong> :&ensp;<code>tuple[float, float, float]</code></dt>
<dd>Coordinates of location</dd>
<dt><strong><code>groups</code></strong> :&ensp;<code>set[str]</code></dt>
<dd>Set of landmark groups this location belongs to.</dd>
<dt><strong><code>landmarks</code></strong> :&ensp;<code>set[str]</code></dt>
<dd>Set of landmarks this location belongs to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Location:
    &#34;&#34;&#34;Location of importance to landmarks and groups.

    Attributes
    ----------
    xyz : tuple[float, float, float]
        Coordinates of location
    groups : set[str]
        Set of landmark groups this location belongs to.
    landmarks : set[str]
        Set of landmarks this location belongs to.
    &#34;&#34;&#34;

    xyz: tuple[float, float, float]
    groups: set[str] = field(default_factory=set)
    landmarks: set[str] = field(default_factory=set)

    def to_jso(self) -&gt; dict[str, Any]:
        &#34;&#34;&#34;Convert to JSON-serialisable object.

        Returns
        -------
        dict[str, Any]
        &#34;&#34;&#34;
        d = asdict(self)
        d[&#34;xyz&#34;] = list(d[&#34;xyz&#34;])
        d[&#34;groups&#34;] = sorted(d[&#34;groups&#34;])
        d[&#34;landmarks&#34;] = sorted(d[&#34;landmarks&#34;])
        return d

    @classmethod
    def from_jso(cls, jso: dict[str, Any]) -&gt; Location:
        &#34;&#34;&#34;Instantiate from JSON-like dict.

        Parameters
        ----------
        jso : dict[str, Any]
            Keys ``&#34;xyz&#34;`` (3-length list of float),
            ``&#34;groups&#34;`` (list of str),
            ``&#34;landmarks&#34;`` (list of str)

        Returns
        -------
        Location
        &#34;&#34;&#34;
        return cls(
            tuple(jso[&#34;xyz&#34;]),
            set(jso[&#34;groups&#34;]),
            set(jso[&#34;landmarks&#34;]),
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="catmaid_publish.landmarks.Location.groups"><code class="name">var <span class="ident">groups</span> : set[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="catmaid_publish.landmarks.Location.landmarks"><code class="name">var <span class="ident">landmarks</span> : set[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="catmaid_publish.landmarks.Location.xyz"><code class="name">var <span class="ident">xyz</span> : tuple[float, float, float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="catmaid_publish.landmarks.Location.from_jso"><code class="name flex">
<span>def <span class="ident">from_jso</span></span>(<span>jso: dict[str, Any]) ‑> <a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a></span>
</code></dt>
<dd>
<div class="desc"><p>Instantiate from JSON-like dict.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>jso</code></strong> :&ensp;<code>dict[str, Any]</code></dt>
<dd>Keys <code>"xyz"</code> (3-length list of float),
<code>"groups"</code> (list of str),
<code>"landmarks"</code> (list of str)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_jso(cls, jso: dict[str, Any]) -&gt; Location:
    &#34;&#34;&#34;Instantiate from JSON-like dict.

    Parameters
    ----------
    jso : dict[str, Any]
        Keys ``&#34;xyz&#34;`` (3-length list of float),
        ``&#34;groups&#34;`` (list of str),
        ``&#34;landmarks&#34;`` (list of str)

    Returns
    -------
    Location
    &#34;&#34;&#34;
    return cls(
        tuple(jso[&#34;xyz&#34;]),
        set(jso[&#34;groups&#34;]),
        set(jso[&#34;landmarks&#34;]),
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="catmaid_publish.landmarks.Location.to_jso"><code class="name flex">
<span>def <span class="ident">to_jso</span></span>(<span>self) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert to JSON-serialisable object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Any]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_jso(self) -&gt; dict[str, Any]:
    &#34;&#34;&#34;Convert to JSON-serialisable object.

    Returns
    -------
    dict[str, Any]
    &#34;&#34;&#34;
    d = asdict(self)
    d[&#34;xyz&#34;] = list(d[&#34;xyz&#34;])
    d[&#34;groups&#34;] = sorted(d[&#34;groups&#34;])
    d[&#34;landmarks&#34;] = sorted(d[&#34;landmarks&#34;])
    return d</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="catmaid_publish" href="index.html">catmaid_publish</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="catmaid_publish.landmarks.get_landmarks" href="#catmaid_publish.landmarks.get_landmarks">get_landmarks</a></code></li>
<li><code><a title="catmaid_publish.landmarks.write_landmarks" href="#catmaid_publish.landmarks.write_landmarks">write_landmarks</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="catmaid_publish.landmarks.LandmarkReader" href="#catmaid_publish.landmarks.LandmarkReader">LandmarkReader</a></code></h4>
<ul class="">
<li><code><a title="catmaid_publish.landmarks.LandmarkReader.get_all" href="#catmaid_publish.landmarks.LandmarkReader.get_all">get_all</a></code></li>
<li><code><a title="catmaid_publish.landmarks.LandmarkReader.get_group" href="#catmaid_publish.landmarks.LandmarkReader.get_group">get_group</a></code></li>
<li><code><a title="catmaid_publish.landmarks.LandmarkReader.get_group_names" href="#catmaid_publish.landmarks.LandmarkReader.get_group_names">get_group_names</a></code></li>
<li><code><a title="catmaid_publish.landmarks.LandmarkReader.get_landmark" href="#catmaid_publish.landmarks.LandmarkReader.get_landmark">get_landmark</a></code></li>
<li><code><a title="catmaid_publish.landmarks.LandmarkReader.get_landmark_names" href="#catmaid_publish.landmarks.LandmarkReader.get_landmark_names">get_landmark_names</a></code></li>
<li><code><a title="catmaid_publish.landmarks.LandmarkReader.get_paired_locations" href="#catmaid_publish.landmarks.LandmarkReader.get_paired_locations">get_paired_locations</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="catmaid_publish.landmarks.Location" href="#catmaid_publish.landmarks.Location">Location</a></code></h4>
<ul class="">
<li><code><a title="catmaid_publish.landmarks.Location.from_jso" href="#catmaid_publish.landmarks.Location.from_jso">from_jso</a></code></li>
<li><code><a title="catmaid_publish.landmarks.Location.groups" href="#catmaid_publish.landmarks.Location.groups">groups</a></code></li>
<li><code><a title="catmaid_publish.landmarks.Location.landmarks" href="#catmaid_publish.landmarks.Location.landmarks">landmarks</a></code></li>
<li><code><a title="catmaid_publish.landmarks.Location.to_jso" href="#catmaid_publish.landmarks.Location.to_jso">to_jso</a></code></li>
<li><code><a title="catmaid_publish.landmarks.Location.xyz" href="#catmaid_publish.landmarks.Location.xyz">xyz</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>