! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).


MODULE C_PRUNE
USE ISO_FORTRAN_ENV , ONLY : INT64
  IMPLICIT NONE


CONTAINS


  
  SUBROUTINE C_INNER(TREE_SIZE, LEVELS, INDICES_DIM_1, INDICES, CURRENT_LEVEL_PRESENT, CURRENT_LEVEL, STARTING_INDEX_PRESENT, START&
&ING_INDEX, NEXT_INDEX_PRESENT, NEXT_INDEX) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE PRUNE, ONLY: INNER
    IMPLICIT NONE
    INTEGER(KIND=INT64), INTENT(IN) :: TREE_SIZE
    INTEGER(KIND=INT64), INTENT(IN) :: LEVELS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(OUT), DIMENSION(INDICES_DIM_1) :: INDICES
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: CURRENT_LEVEL_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: CURRENT_LEVEL
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: STARTING_INDEX_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: STARTING_INDEX
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: NEXT_INDEX_PRESENT
    INTEGER(KIND=INT64), INTENT(INOUT) :: NEXT_INDEX
  
    IF (CURRENT_LEVEL_PRESENT) THEN
      IF (STARTING_INDEX_PRESENT) THEN
        IF (NEXT_INDEX_PRESENT) THEN
          CALL INNER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL, STARTING_INDEX=STARTING_INDE&
&X, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL INNER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL, STARTING_INDEX=STARTING_INDE&
&X)
        END IF
      ELSE
        IF (NEXT_INDEX_PRESENT) THEN
          CALL INNER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL INNER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL)
        END IF
      END IF
    ELSE
      IF (STARTING_INDEX_PRESENT) THEN
        IF (NEXT_INDEX_PRESENT) THEN
          CALL INNER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, STARTING_INDEX=STARTING_INDEX, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL INNER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, STARTING_INDEX=STARTING_INDEX)
        END IF
      ELSE
        IF (NEXT_INDEX_PRESENT) THEN
          CALL INNER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL INNER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES)
        END IF
      END IF
    END IF
  END SUBROUTINE C_INNER
  

  
  SUBROUTINE C_OUTER(TREE_SIZE, LEVELS, INDICES_DIM_1, INDICES, CURRENT_LEVEL_PRESENT, CURRENT_LEVEL, STARTING_INDEX_PRESENT, START&
&ING_INDEX, NEXT_INDEX_PRESENT, NEXT_INDEX) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE PRUNE, ONLY: OUTER
    IMPLICIT NONE
    INTEGER(KIND=INT64), INTENT(IN) :: TREE_SIZE
    INTEGER(KIND=INT64), INTENT(IN) :: LEVELS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(OUT), DIMENSION(INDICES_DIM_1) :: INDICES
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: CURRENT_LEVEL_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: CURRENT_LEVEL
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: STARTING_INDEX_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: STARTING_INDEX
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: NEXT_INDEX_PRESENT
    INTEGER(KIND=INT64), INTENT(INOUT) :: NEXT_INDEX
  
    IF (CURRENT_LEVEL_PRESENT) THEN
      IF (STARTING_INDEX_PRESENT) THEN
        IF (NEXT_INDEX_PRESENT) THEN
          CALL OUTER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL, STARTING_INDEX=STARTING_INDE&
&X, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL OUTER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL, STARTING_INDEX=STARTING_INDE&
&X)
        END IF
      ELSE
        IF (NEXT_INDEX_PRESENT) THEN
          CALL OUTER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL OUTER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL)
        END IF
      END IF
    ELSE
      IF (STARTING_INDEX_PRESENT) THEN
        IF (NEXT_INDEX_PRESENT) THEN
          CALL OUTER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, STARTING_INDEX=STARTING_INDEX, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL OUTER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, STARTING_INDEX=STARTING_INDEX)
        END IF
      ELSE
        IF (NEXT_INDEX_PRESENT) THEN
          CALL OUTER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL OUTER(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES)
        END IF
      END IF
    END IF
  END SUBROUTINE C_OUTER
  

  
  SUBROUTINE C_TOP(TREE_SIZE, LEVELS, INDICES_DIM_1, INDICES, CURRENT_LEVEL_PRESENT, CURRENT_LEVEL, STARTING_INDEX_PRESENT, STARTIN&
&G_INDEX, NEXT_INDEX_PRESENT, NEXT_INDEX) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE PRUNE, ONLY: TOP
    IMPLICIT NONE
    INTEGER(KIND=INT64), INTENT(IN) :: TREE_SIZE
    INTEGER(KIND=INT64), INTENT(IN) :: LEVELS
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(OUT), DIMENSION(INDICES_DIM_1) :: INDICES
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: CURRENT_LEVEL_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: CURRENT_LEVEL
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: STARTING_INDEX_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: STARTING_INDEX
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: NEXT_INDEX_PRESENT
    INTEGER(KIND=INT64), INTENT(INOUT) :: NEXT_INDEX
  
    IF (CURRENT_LEVEL_PRESENT) THEN
      IF (STARTING_INDEX_PRESENT) THEN
        IF (NEXT_INDEX_PRESENT) THEN
          CALL TOP(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL, STARTING_INDEX=STARTING_INDEX,&
& NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL TOP(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL, STARTING_INDEX=STARTING_INDEX)
        END IF
      ELSE
        IF (NEXT_INDEX_PRESENT) THEN
          CALL TOP(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL TOP(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, CURRENT_LEVEL=CURRENT_LEVEL)
        END IF
      END IF
    ELSE
      IF (STARTING_INDEX_PRESENT) THEN
        IF (NEXT_INDEX_PRESENT) THEN
          CALL TOP(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, STARTING_INDEX=STARTING_INDEX, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL TOP(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, STARTING_INDEX=STARTING_INDEX)
        END IF
      ELSE
        IF (NEXT_INDEX_PRESENT) THEN
          CALL TOP(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES, NEXT_INDEX=NEXT_INDEX)
        ELSE
          CALL TOP(TREE_SIZE=TREE_SIZE, LEVELS=LEVELS, INDICES=INDICES)
        END IF
      END IF
    END IF
  END SUBROUTINE C_TOP
  

  
  SUBROUTINE C_LEVEL(TREE_SIZE, LAYER, INDICES_DIM_1, INDICES, FOUND, STARTING_INDEX_PRESENT, STARTING_INDEX) BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE PRUNE, ONLY: LEVEL
    IMPLICIT NONE
    INTEGER(KIND=INT64), INTENT(IN) :: TREE_SIZE
    INTEGER(KIND=INT64), INTENT(IN) :: LAYER
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(OUT), DIMENSION(INDICES_DIM_1) :: INDICES
    INTEGER(KIND=INT64), INTENT(INOUT) :: FOUND
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: STARTING_INDEX_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: STARTING_INDEX
  
    IF (STARTING_INDEX_PRESENT) THEN
      CALL LEVEL(TREE_SIZE=TREE_SIZE, LAYER=LAYER, INDICES=INDICES, FOUND=FOUND, STARTING_INDEX=STARTING_INDEX)
    ELSE
      CALL LEVEL(TREE_SIZE=TREE_SIZE, LAYER=LAYER, INDICES=INDICES, FOUND=FOUND)
    END IF
  END SUBROUTINE C_LEVEL
  
END MODULE C_PRUNE

