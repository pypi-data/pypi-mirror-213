! This automatically generated Fortran wrapper file allows codes
! written in Fortran to be called directly from C and translates all
! C-style arguments into expected Fortran-style arguments (with
! assumed size, local type declarations, etc.).


MODULE C_FAST_SELECT
USE ISO_FORTRAN_ENV , ONLY : REAL32 , INT64
USE SWAP , ONLY : SWAP_I64 , SWAP_R32
  IMPLICIT NONE


CONTAINS


  
  SUBROUTINE C_ARGSELECT(VALUES_DIM_1, VALUES, INDICES_DIM_1, INDICES, K, DIVISOR_PRESENT, DIVISOR, MAX_SIZE_PRESENT, MAX_SIZE) BIN&
&D(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE FAST_SELECT, ONLY: ARGSELECT
    IMPLICIT NONE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: VALUES_DIM_1
    REAL(KIND=REAL32), INTENT(INOUT), DIMENSION(VALUES_DIM_1) :: VALUES
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(INDICES_DIM_1) :: INDICES
    INTEGER(KIND=INT64), INTENT(IN) :: K
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: DIVISOR_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: DIVISOR
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: MAX_SIZE_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: MAX_SIZE
  
    IF (DIVISOR_PRESENT) THEN
      IF (MAX_SIZE_PRESENT) THEN
        CALL ARGSELECT(VALUES=VALUES, INDICES=INDICES, K=K, DIVISOR=DIVISOR, MAX_SIZE=MAX_SIZE)
      ELSE
        CALL ARGSELECT(VALUES=VALUES, INDICES=INDICES, K=K, DIVISOR=DIVISOR)
      END IF
    ELSE
      IF (MAX_SIZE_PRESENT) THEN
        CALL ARGSELECT(VALUES=VALUES, INDICES=INDICES, K=K, MAX_SIZE=MAX_SIZE)
      ELSE
        CALL ARGSELECT(VALUES=VALUES, INDICES=INDICES, K=K)
      END IF
    END IF
  END SUBROUTINE C_ARGSELECT
  

  
  SUBROUTINE C_ARGSELECT_I64(VALUES_DIM_1, VALUES, INDICES_DIM_1, INDICES, K, DIVISOR_PRESENT, DIVISOR, MAX_SIZE_PRESENT, MAX_SIZE)&
& BIND(C)
    USE ISO_C_BINDING, ONLY: C_BOOL
    USE FAST_SELECT, ONLY: ARGSELECT_I64
    IMPLICIT NONE
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: VALUES_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(VALUES_DIM_1) :: VALUES
    INTEGER(KIND=SELECTED_INT_KIND(18)), INTENT(IN) :: INDICES_DIM_1
    INTEGER(KIND=INT64), INTENT(INOUT), DIMENSION(INDICES_DIM_1) :: INDICES
    INTEGER(KIND=INT64), INTENT(IN) :: K
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: DIVISOR_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: DIVISOR
    LOGICAL(KIND=C_BOOL), INTENT(IN) :: MAX_SIZE_PRESENT
    INTEGER(KIND=INT64), INTENT(IN) :: MAX_SIZE
  
    IF (DIVISOR_PRESENT) THEN
      IF (MAX_SIZE_PRESENT) THEN
        CALL ARGSELECT_I64(VALUES=VALUES, INDICES=INDICES, K=K, DIVISOR=DIVISOR, MAX_SIZE=MAX_SIZE)
      ELSE
        CALL ARGSELECT_I64(VALUES=VALUES, INDICES=INDICES, K=K, DIVISOR=DIVISOR)
      END IF
    ELSE
      IF (MAX_SIZE_PRESENT) THEN
        CALL ARGSELECT_I64(VALUES=VALUES, INDICES=INDICES, K=K, MAX_SIZE=MAX_SIZE)
      ELSE
        CALL ARGSELECT_I64(VALUES=VALUES, INDICES=INDICES, K=K)
      END IF
    END IF
  END SUBROUTINE C_ARGSELECT_I64
  
END MODULE C_FAST_SELECT

