# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['singleton2', 'singleton2.migrations']

package_data = \
{'': ['*']}

install_requires = \
['django-appconf>=1.0.5,<2.0.0',
 'django-environ>=0.9.0,<0.10.0',
 'django>=3.2,<5.0']

setup_kwargs = {
    'name': 'django-singleton2',
    'version': '0.1.1',
    'description': '',
    'long_description': ' \n<!-- # django-singleton -->\n\n[![Documentation Status](https://readthedocs.org/projects/django-singleton2/badge/?version=latest)](https://django-singleton2.readthedocs.io/en/latest/?badge=latest)\n\n- [The app](#the-app)\n  - [Installation](#installation)\n  - [Configuration](#configuration)\n  - [Usage](#usage)\n- [The process of creating the app](#the-process-of-creating-the-app)\n  - [Operating System](#operating-system)\n  - [Project Structure](#project-structure)\n  - [setup a sensible environment (part 1)](#setup-a-sensible-environment-part-1)\n    - [pyenv](#pyenv)\n    - [poetry](#poetry)\n    - [tox](#tox)\n    - [pytest](#pytest)\n    - [black](#black)\n    - [sphinx](#sphinx)\n  - [bootstrap your repository](#bootstrap-your-repository)\n    - [bootstrapping the app](#bootstrapping-the-app)\n    - [boostrapping the project to develop against](#boostrapping-the-project-to-develop-against)\n    - [bootstrapping the documentation](#bootstrapping-the-documentation)\n  - [setup a sensible environment (part 2)](#setup-a-sensible-environment-part-2)\n  - [coding](#coding)\n    - [connect the app to the example-project](#connect-the-app-to-the-example-project)\n    - [documenting the code](#documenting-the-code)\n    - [testing the code](#testing-the-code)\n    - [versioning the code](#versioning-the-code)\n    - [packaging \\& publishing the code](#packaging--publishing-the-code)\n  - [continuous integration (workflows)](#continuous-integration-workflows)\n- [I AM HERE](#i-am-here)\n      - [tox](#tox-1)\n      - [github actions](#github-actions)\n    - [publish](#publish)\n\n-----\n\n# The app\n\nA singleton is a class that can only be instanciated a single time.  `SingletonMixin` turns any Django Model into a singleton.  \n\n## Installation\n\nInstall with pip or your favorite Python package manager.\n\n```\npip install django-singleton2\n```\n\nAdd "singleton2" to your `INSTALLED_APPS`\n\n```\nINSTALLED_APPS = [\n  ...\n  \'singleton2\',\n]\n```\n\n## Configuration\n\nUpdate _settings.py_ if you feel like it:\n\n```\nSINGLETON_RAISE_ERROR_ON_SAVE = True|False\n```\n\nThe default value is False.\n\n## Usage\n\n```\nfrom django.db import models\nfrom singleton2.models import SingletonMixin\n\nclass MySingletonModel(SingletonMixin, models.Model):\n  pass\n\nmy_singleton_instance = MySingletonModel.load()\n```\n\nValidation errors will ocurr if you try to save more than one instance of a singleton via a form (such as in the Django Admin).  These will be handled by normal Django form processing.  \n\nIf you try to save more than one instance of a singleton outside of a form then nothing will happen, unless `SINGLETON_RAISE_ERROR_ON_SAVE` is set to True in which case an exception will be raised.\n\n\n> **Note** that the app is called "django-singleton2" because there is an existing [django-singleton](https://github.com/defbyte/django-singleton) app which does the same thing and works perfectly well.  \n\n-----\n\n# The process of creating the app\n\nAll the stuff that other people seem to already know is described here.\n\n## Operating System\n\nI do all of my coding on Linux because I\'m not insane.  I use Xubuntu because Ubuntu is pretty standard, but I\'m used to having lousy hardware and XFCE takes less processing power than Unity.  Plus, I\'m used to it.\n\nThese days, a lot of development is done in Docker.  So the underlying OS doesn\'t really matter.  Still, if I can avoid virutalization I will.  This Django Reusable App does not rely on Docker for development purposes.\n\n## Project Structure\n\nFirst create the repository in GiHub.  In theory this can be done from the command line using [gh]([https://cli.github.com/), but honestly, I find using the GitHub website GUI a lot more straightforward.  Plus doing it this way can automatically create the "README.md" and "LICENCE" files for you.  \n\nOnce that has been done, clone this repository into your local filesystem and then setup the basic directory structure:\n\n```\ngit clone git@github.com:allynt/django-singleton2.git django-singleton\nmkdir -p django-singleton/singleton2\nmkdir -p django-singleton/example-project\nmkdir -p django-singleton/docs\nmkdir -p django-singleton/.github\ncd django-singleton/\n```\n\nThis provides us with a place to store the app, an example project to develop against, documentation, and workflows for CI.\n\nNote that the repository already comes with a ".gitingore" file.  This has been generated from [gitignore.io](https://www.toptal.com/developers/gitignore/api/django,linux,python) with a few extra bits tacked onto the end:\n\n```\n# static & media files\nexample-project/_static/*\nexample-project/_media/*\n\n# pytest output\nexample-project/pytest-report.html\nexample-project/output.json\nexample-project/archive\n\n# local environment variables\n.env.*\n\n# in progress files\n*.bak\n*.orig\n```\nYou should override this according to your needs.\n\nNow that that\'s all out of the way run\n\n```\ngit add .\ngit commit -m "initial commit"\ngit push\n```\n\nto make sure that github and your local filesystem are in sync.\n\nSince you\'re using github, now would be as good a time as any to create some templates to help potential collaborators.  I have created issue templates for "bug_reports" and "feature_requests" as well as a pull request template.  Again, this could have been done by manually creating files in ".github" but I find working with the GitHub GUI simpler (and it lets me build upon their existing templates).\n\nI also created a CODE_OF_CONDUCT.md file (as per [here](https://docs.github.com/en/communities/setting-up-your-project-for-healthy-contributions/adding-a-code-of-conduct-to-your-project)) and a CONTRIBUTING.md file (as per [here](https://github.com/nayafia/contributing-template)).\n\nNow that that\'s all out of the way run\n\n```\ngit pull\n```\n\nto make sure that github and your local filesystem are in sync *again*.\n\n## setup a sensible environment (part 1)\n\nIn order to develop code efficiently I use some standard Python tooling.\n\n### pyenv\n\nI use **pyenv** to manage my Python versions.\n\nTo install pyenv first make sure the dependencies are installed:\n\n```\nsudo apt-get install -y make build-essential libssl-dev zlib1g-dev \\\nlibbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev \\\nlibncursesw5-dev xz-utils tk-dev libffi-dev liblzma-dev python-openssl\n```\n\nThen install pyenv itself:\n```\n$ curl https://pyenv.run | bash\n```\n\nand add the following to "~/.bashrc":\n\n```\nexport PATH="$HOME/.pyenv/bin:$PATH"\neval "$(pyenv init -)"\neval "$(pyenv virtualenv-init -)"\n```\n\nReload the shell and install your favorite versions of python.  Then instruct pyenv which version to use in the repository; I\'m using "3.10.0" at the time of writing.\n\n`pyenv local 3.10.0`\n\nThis should create a "django-singleton2/.python-version" file.\n\n### poetry\n\nPython package management is hard.  There is also no one standard way of doing it.  Like most developers, I started with **pip** and migrated to **pipenv** and toyed with **piptools** and embraced **poetry** and am intrigued by **pdm** (but dissappointed that [PEP582](https://peps.python.org/pep-0582/) was not endorsed - that would have made working w/ code inside _and_ outside Docker containers much easier).  Poetry handles virtual environments and package dependency management as well as building and publishing code.  To install it simply run:\n\n```\ncurl -sSL https://install.python-poetry.org | python3 -\npoetry self update\npoetry completions bash >> ~/.bash_completion\n```\n\nNote that the resultant completions file doesnâ€™t work in all versions of bash; multi-word case statements have to be encased in quotes.\n\nNext setup some config:\n\n```\npoetry config virtualenvs.in-project true`\n```\n\nThis ensures that all virtual environments will be located in the project directory in a directory called ".venv".  This is very useful for integrating your virtual environments with your IDEs as we\'ll see later on.\n\nFrom here on, when I instruct you to install a specific python package you should use poetry to be doing this.  All the installed packages will be recorded in a "pyproject.toml" file.  As you develop it is a good idea to generate a "poetry.lock" file that locks all dependencies to a specific version.  \n\nI would say that this is essential when developing a Django Project but not when developing a Django Reusable App.  Anybody that uses it will incorporate it into their own "poetry.lock" file.  And, anyway, tox will reinstall dependencies during testing as we\'ll see later.  \n\nDon\'t forget to run `poetry init` to create your virtual environment and get the whole process started.\n### tox\n\n**Tox** allows me to test my app across multiple library versions.  When writing Django Resuable Apps, the main libraries you care about are Python and Django, obviously.  If this were a more complex app, I might choose to test against multiple versions of other libraries such as Django Rest Framework.\n\nInstalling tox with poetry is very straightforward:\n\n`poetry add --group dev tox="*"`\n\nNote that this installs it as a "dev" dependency which means that poetry will not bundle the tox package when building districution of our app.  \n\ntox is configured with a tox.ini file.  For a start I recommend:\n\n```\n[tox]\nenvlist = py{38,310}-django{32,40,41}\nisolated_build = true\n\n[testenv]\nallowlist_externals = \n    poetry\ndeps =\n    pytest\ncommands_pre = \n    poetry install --no-root --sync\ncommands =\n    poetry run pytest ./example-project\n```\n\nI will add to this file throughout this document.  And I will write more about tox in the testing section.\n\n### pytest\n\nDjango comes with its own testing framework.  And it\'s pretty good.  If you are content with it that\'s fine.  I like to have a bit more control over my test runners.  And I like the way that pytest uses fixtures.  And I\'ve just gotten used to it over the years.  So I use **pytest**. \n\n`poetry add --group dev pytest pytest-django pytest-html-reporter factory-boy`\n\nThere are several useful [pytest plugins](https://docs.pytest.org/en/7.2.x/reference/plugin_list.html) you can add if you like.\n\nI\'ll write more about pytest in the testing section.\n\n### black\n\nI use **black** for linting because I like my code to be pretty.  Install it like this:\n\n`poetry add --group dev black`\n\nI have usually used **yapf** (Yet Another Python Formatter) because it can be configured and there are just a few personal stylistic idiosynchrasies that bug me.  But when writing a Django Reusable App where other developers might contribute, I concede that it makes sense to use something that can\'t be configured and therefore makes it impossible to get into arguments about coding style.  Hence, **black**.\n\n### sphinx\n\n\nI use **sphinx** for documenting my code.  This will automatically parse docstings in code as follows::\n\n```\nclass MyClass(object):\n  """\n  I am a docstring for the class\n  """\n\n  def my_function(self, *args, **kwargs):\n    """\n    I am another docstring for the function\n    """\n    pass\n\n  \n  my_variable = True\n  """\n  I am yet another docstring for the variable\n  (notice how I come after the definition)\n  """\n  \n  pass\n```\n\nWhen I have comments that I don\'t need to be documented, I use the following syntax:\n\n```\ndef my_complex_function(*args, **kwargs):\n  for i in range(100):\n    # this is a complex process that I want to leave a comment about, but I don\'t need sphinx to parse it\n    do_something(i)\n```\n\nInstall sphinx, and some associated packages that I like, using\n\n`poetry add --group docs sphinx sphinx-rtd-theme myst-parser`\n\nBy default sphinx can parse ReStructuredText documents.  `myst-parser` allows it to parse MarkDown (which is not only more intuitive, it is also what GitHub wrote your README file in).  And `sphinx-rtd-theme` incorporates the standard theme used by ReadTheDocs - which is where our documentation is going to wind up (assuming this app is going to be public).\n\n## bootstrap your repository\n\nRecall that we created some empty directories at the root of our repository.  We can now flesh them out with actual content.  I have created several templates that can be used to help with this process.  If you don\'t like my templates, then just use the standard bootstrapping tools.  If you find my templates too complex, then just copy this repository and change the bits you don\'t like.\n\n### bootstrapping the app\n\nThis is easy.  Just run:\n\n`django-admin startapp --template=https://github.com/allynt/django-reusable-app-template/archive/master.zip singleton2` \n\nand the "singleton2" directory will be populated with the stubs needed to develop your app. \n\nThis is a pretty standard Django App with the following tweaks:\n\n* "apps.py" tries to register any checks and signals associated w/ the app\n* "checks.py" includes some standard checks I run against all my apps; these can be expanded as needed\n* "conf.py" includes app-specific configuration using the **django-appconf** reusable app\n* "urls.py" includes an empty `urlpatterns` array that will be referenced by the example-project below\n\n### boostrapping the project to develop against\n\nThis is also easy:\n\n`django-admin startproject --template=https://github.com/allynt/django-reusable-app-project-template/archive/master.zip example example-project` \n\nto populate the "example-project" directory.\n\nWhen developing a Resuable Django App, there are different approaches to testing and building migrations.  I\'ve come across a lot of apps that just don\'t document this at all.  I\'ve come across others that have special scripts which *fake* a Django Project (ie: just a minimal "settings.py" file) to run `django.setup()` with so that the app can be loaded in order to generate migrations.  But I feel like it makes sense to use a *real* Django Project so that you can interact with your app naturally.  \n\nTherefore the "example-project" that I create can be run just like any other Django Project.  It will allow me to generate migrations.  And it will allow me to run tests (located in "example-project/example/tests").  But, crucially, it will also allow me to hack about and make sure I understand exactly how the app works.\n\nI am quite partial to many of the ideas recommended by Cookiecuter Django and so this example-project uses some of their ideas.\n\n* a separate app called "config" where all project-level configurations like "settings.py" and "urls.py" go\n* an app called "example" where all the code that will use the Django Resuable App goes - this includes a "tests" module \n* some custom additions to the "settings.py" file, including the use of **django-environ** to read environment variables\n\n### bootstrapping the documentation\n\nAs mentioned above I use sphinx for the documentation.  I have provided a template that tweaks the default documentation structure - including linking the README.md file and autogenerated documentation to the index page.  This template is available at [https://github.com/allynt/django-reusable-app-sphinx-template](https://github.com/allynt/django-reusable-app-sphinx-template).  At the time of writing, the sphinx CLI cannot use a remote template, therefore this repository must first be cloned locally and then the following command\n\n`cd docs && sphinx-quickstart --templatedir=django-reusable-app-sphinx-template/templates .` will create some initial documentation.\n\nYou can add any additional documentation files you want within the "doc" directory.  Just make sure to include a reference to it underneath the `:toc` directive in "index.rst".  \n## setup a sensible environment (part 2)\n\nAn IDE makes life a lot easier.  I use **VSCode**.  I have therefore included a ".vscode/settings.json" file (and a generic ".editorconfig" file) to configure a few nice features.  My configuration includes a path to the virtual environment created by poetry (".venv") in order to do code-completion as well as linting. \n\nIn theory, keeping these files with the repository not only makes it easier for *me* to code, it makes it less likely for *you* to push code that conflicts with my style.\n\n> *TODO* Although, I may also add a github action to automatically lint all incoming code.\n\nI also have some particularly useful VSCode plugins installed:\n* MS Python (this will install loads of other useful plugins)\n* Markdown all in one\n* Better comments\n* Better ToML\n* DotENV\n* Intellicode\n* Tabnine\n\n*Actually, I use a few more plugins for full-stack development, but these are the ones that are relevant for creating Django Resuable Apps.*\n\n## coding\n\nSo that is most of the setup required before finally diving into actual coding.  There are a few other things that are needed to actually run, test, document, publish, etc. the code.\n\n### connect the app to the example-project\n\nObviously, we need to tell **example-project** about **django-singleton2**.  This is very straightforward, just add the following to "example-project/config/settings.py":\n\n```\nLOCAL_APPS = [\n    "singleton2",\n    "example",\n]\n```\n\nIf your app is more complex then there will probably be some additional configuration needed, such as adding your views to "example-project/config/urls.py", etc.\n\nYou also need to make sure that all of your app\'s dependencies are installed:\n\n`poetry add django django-appconf django-environ`\n\nNow try running `poetry run ./example-project/manage.py runserver` and see if something appears at "localhost:8000".  If not, you messed up.\n\n### documenting the code\n\nI have already discussed using **sphinx** to automatically generate some nice documentation.  I am going to host my documentation on readthedocs because I deserve it.  This requires registering the repository with readthedocs.  There is probably a way to do this on the command line, but I just signed up for an account on readthedocs.org and then manaually used their GUI to import this repostiroy.  \n\nHaving done that, it might look pretty if you add their badge to the README.md file:\n\n```\n[![Documentation Status](https://readthedocs.org/projects/django-singleton2/badge/?version=latest)](https://django-singleton2.readthedocs.io/en/latest/?badge=latest)\n```\n\nI am using tox to generate documentation because *why not*?  I have added a separate section to the "tox.ini" file to deal w/ this.  Now, the [official tox documentation](https://tox.wiki/en/latest/example/documentation.html#sphinx) recommends bypassing the Makefile generated by `sphinx-quickstart` but I disagree.  Why *wouldn\'t* I want to continue using the official approved way of generating documentation?  All I want to do w/ tox is to eventually integrate this into CI and just run `poetry run tox -e docs`.\n\nAnyway, doing things the "official" way got pretty complicated b/c of dependencies.  So I added `make` to the commands in "allowlist_externals" and added the following section:\n\n```\n[testenv:docs]\ndeps = \n    sphinx\n    sphinx-rtd-theme\n    myst-parser\nchangedir = docs\ncommands = \n    make clean\n    make html SPHINXOPTS="-v"\n```\n\nIn order for this to work I had to create a ".readthedocs.yml" file which points to "docs/requirements.txt" in order to specify exactly what dependencies are required to run the codebase (since it needs to be loaded for auto-generated documentation).  Although readthedocs *can* parse the "pyproject.toml" file, it ignores grouped dependencies.  So to populate "docs/requirements.txt" I ran `poetry export -f requirments.txt --only docs --output docs/requirements.txt`.\n\nHaving done all of this will result in https://django-singleton2.readthedocs.io being auto-generated whenever the master branch is pushed to.\n\nIf you want additional auto-generated code documentation, just modify "docs/singleton2.rst" to specify which modules / classes / methods should be included.\n### testing the code\n\nAs mentioned earlier, I use **pytest** as my test runner and **tox** to coordinate testing across multiple environments.  This all requires a bit more config.  First make sure **pytest-django** and **factory-boy** are installed.  These make pytest work a bit nicer w/ Django.  The general syntax I use for a test is:\n\n> *TODO* Add test artefacts from pytest-html-reporter\n\n```\nimport factory\nimport pytest\n\nfrom example.models import ExampleSingletonModel\n\nclass ExampleSingletonModelFactory(factory.django.DjangoModelFactory):\n    """\n    creates an instance of ExampleSingletonModel w/ random field values to use in tests\n    """\n    class Meta:\n        model = ExampleSingletonModel\n\n    name = factory.Faker("word")\n\n@pytest.mark.django_db\nclass TestSingleton:\n    """\n    collection of test methods that hit the Django database\n    """\n    def test_something(self):\n        singleton = ExampleSingletonModelFactory()\n        assert singleton_1.pk is not None\n```\n\nUsing pytest requires a "pytest.ini" file w/ the following minimal content:\n\n```\n[pytest]\nDJANGO_SETTINGS_MODULE=config.settings\npython_files = tests.py test_*.py *_tests.py\naddopts = --nomigrations\n```\n\nThis tells pytest how to start Django and which files to run. (It also instructs it not to bother running any unmigrated migrations.)\n\nTo run the tests simply run the following command:\n\n```\npoetry run pytest ./example-project\n```\n \nOr, better yet, add a new section to "tox.ini":\n\n```\n[testenv:coverage]\nskip_install = true\ndeps =\n    coverage\ncommands =\n    poetry run pytest --cov=singleton2 ./example-project\n```\nIf you like you can add a test-coverage report using the **pytest-cov** library.  I am undecided as to whether this is a good idea.  I feel like using it as a measure of test quality gives a false sence of security.  And, anyway, aiming for 100% coverage is unrealistic.  What is important is testing the *relevant* bits of code under *realistic* use-cases.\n\n\nTo run a coverage report simply run the following command:\n\n```\npoetry run pytest --cov=singleton2 ./example-project\n```\n\nThis will measure the coverage of all code under "singleton2" (it focuses on the app and excludes the example-project).  Some of the modules within "singleton2" don\'t really need to be included in a coverage report.  Therefore we can add the following section to "tox.ini"\n\n\nconfiguration file ".coveragerc":\n\n```\n[run]\nomit = singleton2/migrations/*, singleton2/tests/*\n```\n\n### versioning the code\n\n### packaging & publishing the code\n\nAssuming this is a _real_ Django Reusable App you will want to publish to PyPi.\n\nThis requires creating an account on [pypi.org](pypi.org) and creating an API token, then adding that token to your poetry credentials:\n\n`poetry config pypi-token.pypi <token>`\n\nOnce that is configured, packaging and publishing can be done in a single step: `poetry publish --build`.\n## continuous integration (workflows)\n\n# I AM HERE\n  \n\nI\'ll talk about how to configure the documentation below.\nI AM HERE\n\nTODO:\n* distributed tox (just use the -p flag) - done\n* get tox to build documentation - done but turns out its a bad idea\n* push documentation to readthedocs - done\n* look into documentation on github pages (for private repositories)\n* prevent tox from including docs dependencies for tests - done but don\'t like solution\n* run tox on PRs -done\n* https://pypi.org/project/tox-gh-actions/\n* dynamic versioning: https://github.com/mtkennerly/poetry-dynamic-versioning\n* badges\n\n\n#### tox\n\nTox allows me to test a matrix of package versions.  The obvious thing to do is to test it against different versions of Python & Django.  To speed things up you can run tox in parallel via `poetry run tox -p all` (although this doesn\'t provide as much output).\n\n#### github actions\n\nSo I want to use poetry to run tox which uses pytest as the runner automatically whenever code is pushed to github.  I do this using github actions and the clever library tox-gh-actions as well as github\'s publically available [Install Poetry Action](https://github.com/marketplace/actions/install-poetry-action)\n  \n`mkdir -p .github/workflows`\n\nThe section in tox.ini maps github action matrices to tox environments.  For example in the workflow file:\n\n```\nstrategy:\n    matrix:\n      python-version: ["3.8", "3.10"]\n```\n\ndefines 2 versions of python and the corresponding section in the tox config file:\n\n```\n[gh-actions]\npython =\n    3.8: py38\n    3.10: py310\n```\n\nmaps those to the existing "py38" and "py310" arguments at the top of the tox config file.\n\n### publish\n\nuse dev-py\n',
    'author': 'Allyn Treshansky',
    'author_email': 'allyn.treshansky@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
