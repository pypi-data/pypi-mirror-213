import multiprocessing
import platform

import numpy as np

try:
    if platform.system() == "Darwin":
        multiprocessing.set_start_method("spawn")
except:
    pass

from io import BytesIO
from typing import Union
from typing_extensions import Literal

import fitz as mupdf

from edspdf import Pipeline, registry
from edspdf.structures import Box, Page, PDFDoc, TextBox, TextProperties

__version__ = "0.2.0"


@registry.factory.register("mupdf-extractor")
class MuPdfExtractor:
    """
    We provide a PDF line extractor built on top of
    [PyMuPdf](https://pdfminersix.readthedocs.io/en/latest/).

    This extractor is the fastest but may not be as portable as that
    [PdfMinerExtractor][edspdf.pipes.extractors.pdfminer.PdfMinerExtractor].
    However, it should also be relatively easy to install on a wide range of
    architectures, Linux, OS X and Windows.

    !!! warning "License"

        Beware, PyMuPdf is distributed under the AGPL license, therefore so is this
        component, and any model depending on this component must be too.

    Installation
    ------------

    For the licensing reason mentioned above, the `mupdf` component is distributed
    in a separate package `edspdf-mupdf`. To install it, use your favorite Python package manager :

    ```bash
    poetry add edspdf-mupdf
    # or
    pip install edspdf-mupdf
    ```

    Example
    -------

    === "API-based"

        ```python
        pipeline.add_pipe(
            "mupdf-extractor",
            config=dict(
                extract_style=False,
            ),
        )
        ```

    === "Configuration-based"

        ```toml
        [components.mupdf-extractor]
        @factory = "mupdf-extractor"
        extract_style = false
        ```

    and use it as follows:

    ```python
    from pathlib import Path

    # Apply on a new document
    pipeline(Path("path/to/your/pdf/document").read_bytes())
    ```

    Parameters
    ----------
    pipeline: Pipeline
        The pipeline object
    name: str
        Name of the component
    extract_style : bool
        Extract style
    raise_on_error: bool
        Whether to raise an error when parsing a corrupted PDF (defaults to False)
    use_cropbox: bool
        Whether to use the cropbox instead of the mediabox (defaults to True)
    render_pages: bool
        Whether to extract the rendered page as a numpy array in the `page.image`
        attribute (defaults to False)
    render_dpi: int
        DPI to use when rendering the page (defaults to 200)
    sort_mode: Literal["blocks", "lines", "none"]
        Box sorting mode

        - "blocks": sort while keeping blocks of boxes intaxct. Use this mode if you
            trust the PDF to have been generated by a tool that produces blocks of text.
        - "lines": sort by lines, without preserving the order of lines inside blocks
        - "none": do not sort boxes
    """

    def __init__(
        self,
        pipeline: Pipeline = None,
        name: str = "mupdf_extractor",
        extract_style: bool = False,
        render_pages: bool = False,
        render_dpi: int = 200,
        raise_on_error: bool = False,
        use_cropbox: bool = True,
        sort_mode: Literal["blocks", "lines", "none"] = "none",
    ):
        super().__init__()

        self.name = name

        self.extract_style = extract_style
        self.render_pages = render_pages
        self.render_dpi = render_dpi
        self.raise_on_error = raise_on_error
        self.use_cropbox = use_cropbox
        self.sort_mode = sort_mode

    def __call__(self, doc: Union[PDFDoc, bytes]) -> PDFDoc:
        if not isinstance(doc, PDFDoc):
            content = bytes(doc)
            doc = PDFDoc(id=str(hash(content)), content=content)
        content = doc.content

        try:
            mupdf_doc = mupdf.Document(stream=BytesIO(content))
            pages = doc.pages = []

            page_count = 0
            for page_no, mupdf_page in enumerate(mupdf_doc):
                page_count += 1

                if self.use_cropbox:
                    page_w = mupdf_page.cropbox[2] - mupdf_page.cropbox[0]
                    page_h = mupdf_page.cropbox[3] - mupdf_page.cropbox[1]
                else:
                    page_w, page_h = mupdf_page.mediabox_size

                content_boxes = []

                page = Page(
                    doc=doc,
                    page_num=page_no,
                    width=page_w,
                    height=page_h,
                )
                pages.append(page)

                if self.render_pages:
                    pixmap = mupdf_page.get_pixmap(dpi=self.render_dpi)
                    page.image = np.frombuffer(pixmap.samples, dtype=np.uint8).reshape(
                        pixmap.height, pixmap.width, pixmap.n
                    )

                blocks = mupdf_page.get_textpage().extractRAWDICT()["blocks"]
                if self.sort_mode == "blocks":
                    blocks = sorted(
                        blocks,
                        key=lambda b: Box(
                            x0=b["bbox"][0],
                            y0=b["bbox"][1],
                            x1=b["bbox"][2],
                            y1=b["bbox"][3],
                        ),
                    )
                for b in blocks:
                    for line in b["lines"]:
                        text = ""
                        text_properties = []
                        for span in line["spans"]:
                            span_text = "".join(char["c"] for char in span["chars"])
                            span_text = span_text.encode("utf-8", "ignore")
                            span_text = span_text.decode("utf-8")
                            if len(text) == 0:
                                text = span_text.lstrip()
                            else:
                                text += span_text

                            if self.extract_style:
                                end = len(text.rstrip())
                                begin = end - len(span_text.strip())
                                lower_font = span["font"].lower()
                                text_properties.append(
                                    TextProperties(
                                        fontname=span["font"],
                                        italic="italic" in lower_font,
                                        bold="bold" in lower_font,
                                        begin=begin,
                                        end=end,
                                    )
                                )

                        text = text.rstrip()
                        if len(text) > 0:
                            x0 = line["bbox"][0] / page_w
                            y0 = line["bbox"][1] / page_h
                            x1 = line["bbox"][2] / page_w
                            y1 = line["bbox"][3] / page_h

                            if x0 < 0 or x1 > 1 or y0 < 0 or y1 > 1:
                                continue

                            for _ in range(mupdf_page.rotation // 90):
                                x0, y0, x1, y1 = 1 - y1, x0, 1 - y0, x1

                            content_boxes.append(
                                TextBox(
                                    doc=doc,
                                    page_num=page_no,
                                    x0=x0,
                                    x1=x1,
                                    y0=y0,
                                    y1=y1,
                                    text=text,
                                    props=text_properties,
                                )
                            )

                if self.sort_mode == "lines":
                    content_boxes = sorted(content_boxes)
                doc.content_boxes.extend(content_boxes)

        except Exception:
            if self.raise_on_error:
                raise
            doc.pages = []
            doc.error = True
            return doc

        return doc
