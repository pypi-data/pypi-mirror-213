# coding: utf-8

"""
    Diveplane API

    OpenAPI implementation for interacting with the Diveplane API.   # noqa: E501

    The version of the OpenAPI document: 23.7.1
    Contact: diveplane@diveplane.com
    Generated by: https://openapi-generator.tech
"""


try:
    from inspect import getfullargspec
except ImportError:
    from inspect import getargspec as getfullargspec
import pprint
import re  # noqa: F401
import six

from diveplane.openapi.configuration import Configuration


class FeatureTimeSeries(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'type': 'str',
        'order': 'float',
        'derived_orders': 'float',
        'delta_min': 'list[float]',
        'delta_max': 'list[float]',
        'lags': 'list[int]',
        'num_lags': 'float',
        'rate_min': 'list[float]',
        'rate_max': 'list[float]',
        'series_has_terminators': 'bool',
        'stop_on_terminator': 'bool',
        'time_feature': 'bool'
    }

    attribute_map = {
        'type': 'type',
        'order': 'order',
        'derived_orders': 'derived_orders',
        'delta_min': 'delta_min',
        'delta_max': 'delta_max',
        'lags': 'lags',
        'num_lags': 'num_lags',
        'rate_min': 'rate_min',
        'rate_max': 'rate_max',
        'series_has_terminators': 'series_has_terminators',
        'stop_on_terminator': 'stop_on_terminator',
        'time_feature': 'time_feature'
    }

    nullable_attributes = [
    ]

    discriminator = None

    def __init__(self, type='rate', order=None, derived_orders=None, delta_min=None, delta_max=None, lags=None, num_lags=None, rate_min=None, rate_max=None, series_has_terminators=None, stop_on_terminator=None, time_feature=None, local_vars_configuration=None):  # noqa: E501
        """FeatureTimeSeries - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration.get_default_copy()
        self.local_vars_configuration = local_vars_configuration

        self._type = None
        self._order = None
        self._derived_orders = None
        self._delta_min = None
        self._delta_max = None
        self._lags = None
        self._num_lags = None
        self._rate_min = None
        self._rate_max = None
        self._series_has_terminators = None
        self._stop_on_terminator = None
        self._time_feature = None

        self.type = type
        if order is not None:
            self.order = order
        if derived_orders is not None:
            self.derived_orders = derived_orders
        if delta_min is not None:
            self.delta_min = delta_min
        if delta_max is not None:
            self.delta_max = delta_max
        if lags is not None:
            self.lags = lags
        if num_lags is not None:
            self.num_lags = num_lags
        if rate_min is not None:
            self.rate_min = rate_min
        if rate_max is not None:
            self.rate_max = rate_max
        if series_has_terminators is not None:
            self.series_has_terminators = series_has_terminators
        if stop_on_terminator is not None:
            self.stop_on_terminator = stop_on_terminator
        if time_feature is not None:
            self.time_feature = time_feature

    @property
    def type(self):
        """Gets the type of this FeatureTimeSeries.  # noqa: E501

        When 'rate' is specified, it uses the difference of the current value from its previous value divided by the change in time since the previous value. When 'delta' is specified, just uses the difference of the current value from its previous value regardless of the elapsed time. Set to 'delta' if feature has 'time_feature' set to true.   # noqa: E501

        :return: The type of this FeatureTimeSeries.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this FeatureTimeSeries.

        When 'rate' is specified, it uses the difference of the current value from its previous value divided by the change in time since the previous value. When 'delta' is specified, just uses the difference of the current value from its previous value regardless of the elapsed time. Set to 'delta' if feature has 'time_feature' set to true.   # noqa: E501

        :param type: The type of this FeatureTimeSeries.  # noqa: E501
        :type type: str
        """
        if self.local_vars_configuration.client_side_validation and type is None:  # noqa: E501
            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
        allowed_values = ["rate", "delta"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and type not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"  # noqa: E501
                .format(type, allowed_values)
            )

        self._type = type

    @property
    def order(self):
        """Gets the order of this FeatureTimeSeries.  # noqa: E501

        If provided will generate the specified number of derivatives and boundary values.   # noqa: E501

        :return: The order of this FeatureTimeSeries.  # noqa: E501
        :rtype: float
        """
        return self._order

    @order.setter
    def order(self, order):
        """Sets the order of this FeatureTimeSeries.

        If provided will generate the specified number of derivatives and boundary values.   # noqa: E501

        :param order: The order of this FeatureTimeSeries.  # noqa: E501
        :type order: float
        """

        self._order = order

    @property
    def derived_orders(self):
        """Gets the derived_orders of this FeatureTimeSeries.  # noqa: E501

        The number of orders of derivatives that should be derived instead of synthesized. Ignored if order is not provided.   # noqa: E501

        :return: The derived_orders of this FeatureTimeSeries.  # noqa: E501
        :rtype: float
        """
        return self._derived_orders

    @derived_orders.setter
    def derived_orders(self, derived_orders):
        """Sets the derived_orders of this FeatureTimeSeries.

        The number of orders of derivatives that should be derived instead of synthesized. Ignored if order is not provided.   # noqa: E501

        :param derived_orders: The derived_orders of this FeatureTimeSeries.  # noqa: E501
        :type derived_orders: float
        """

        self._derived_orders = derived_orders

    @property
    def delta_min(self):
        """Gets the delta_min of this FeatureTimeSeries.  # noqa: E501

        If specified, ensures that the smallest difference between features values is not smaller than this specified value. A null value means no min boundary. The length of the list must match the number of derivatives as specified by 'order'   # noqa: E501

        :return: The delta_min of this FeatureTimeSeries.  # noqa: E501
        :rtype: list[float]
        """
        return self._delta_min

    @delta_min.setter
    def delta_min(self, delta_min):
        """Sets the delta_min of this FeatureTimeSeries.

        If specified, ensures that the smallest difference between features values is not smaller than this specified value. A null value means no min boundary. The length of the list must match the number of derivatives as specified by 'order'   # noqa: E501

        :param delta_min: The delta_min of this FeatureTimeSeries.  # noqa: E501
        :type delta_min: list[float]
        """

        self._delta_min = delta_min

    @property
    def delta_max(self):
        """Gets the delta_max of this FeatureTimeSeries.  # noqa: E501

        If specified, ensures that the largest difference between feature values is not larger than this specified value. A null value means no max boundary. The length of the list must match the number of derivatives as specified by 'order'   # noqa: E501

        :return: The delta_max of this FeatureTimeSeries.  # noqa: E501
        :rtype: list[float]
        """
        return self._delta_max

    @delta_max.setter
    def delta_max(self, delta_max):
        """Sets the delta_max of this FeatureTimeSeries.

        If specified, ensures that the largest difference between feature values is not larger than this specified value. A null value means no max boundary. The length of the list must match the number of derivatives as specified by 'order'   # noqa: E501

        :param delta_max: The delta_max of this FeatureTimeSeries.  # noqa: E501
        :type delta_max: list[float]
        """

        self._delta_max = delta_max

    @property
    def lags(self):
        """Gets the lags of this FeatureTimeSeries.  # noqa: E501

        When specified, generates lag features containing previous values with lag with the enumerated lag offsets. If specified, num_lags will be ignored. If neither num_lags nor lags is specified for a feature, then a single lag feature is generated.   # noqa: E501

        :return: The lags of this FeatureTimeSeries.  # noqa: E501
        :rtype: list[int]
        """
        return self._lags

    @lags.setter
    def lags(self, lags):
        """Sets the lags of this FeatureTimeSeries.

        When specified, generates lag features containing previous values with lag with the enumerated lag offsets. If specified, num_lags will be ignored. If neither num_lags nor lags is specified for a feature, then a single lag feature is generated.   # noqa: E501

        :param lags: The lags of this FeatureTimeSeries.  # noqa: E501
        :type lags: list[int]
        """

        self._lags = lags

    @property
    def num_lags(self):
        """Gets the num_lags of this FeatureTimeSeries.  # noqa: E501

        When specified, generates the specified amount of lag features containing previous values. If lags is specified, then num_lags will be ignored. If neither num_lags nor lags is specified for a feature, then a single lag feature is generated.   # noqa: E501

        :return: The num_lags of this FeatureTimeSeries.  # noqa: E501
        :rtype: float
        """
        return self._num_lags

    @num_lags.setter
    def num_lags(self, num_lags):
        """Sets the num_lags of this FeatureTimeSeries.

        When specified, generates the specified amount of lag features containing previous values. If lags is specified, then num_lags will be ignored. If neither num_lags nor lags is specified for a feature, then a single lag feature is generated.   # noqa: E501

        :param num_lags: The num_lags of this FeatureTimeSeries.  # noqa: E501
        :type num_lags: float
        """

        self._num_lags = num_lags

    @property
    def rate_min(self):
        """Gets the rate_min of this FeatureTimeSeries.  # noqa: E501

        When specified, ensures that the rate or delta (the difference quotient, the discrete version of derivative) for this feature won't be less than the value provided. A null value means no min boundary. The value must be in epoch format for the time feature. The length of the list must match the number of derivatives as specified by 'order'.   # noqa: E501

        :return: The rate_min of this FeatureTimeSeries.  # noqa: E501
        :rtype: list[float]
        """
        return self._rate_min

    @rate_min.setter
    def rate_min(self, rate_min):
        """Sets the rate_min of this FeatureTimeSeries.

        When specified, ensures that the rate or delta (the difference quotient, the discrete version of derivative) for this feature won't be less than the value provided. A null value means no min boundary. The value must be in epoch format for the time feature. The length of the list must match the number of derivatives as specified by 'order'.   # noqa: E501

        :param rate_min: The rate_min of this FeatureTimeSeries.  # noqa: E501
        :type rate_min: list[float]
        """

        self._rate_min = rate_min

    @property
    def rate_max(self):
        """Gets the rate_max of this FeatureTimeSeries.  # noqa: E501

        When specified, ensures that the rate or delta (the difference quotient, the discrete version of derivative) for this feature won't be less than the value provided. A null value means no max boundary. The value must be in epoch format for the time feature. The length of the list must match the number of derivatives as specified by 'order'   # noqa: E501

        :return: The rate_max of this FeatureTimeSeries.  # noqa: E501
        :rtype: list[float]
        """
        return self._rate_max

    @rate_max.setter
    def rate_max(self, rate_max):
        """Sets the rate_max of this FeatureTimeSeries.

        When specified, ensures that the rate or delta (the difference quotient, the discrete version of derivative) for this feature won't be less than the value provided. A null value means no max boundary. The value must be in epoch format for the time feature. The length of the list must match the number of derivatives as specified by 'order'   # noqa: E501

        :param rate_max: The rate_max of this FeatureTimeSeries.  # noqa: E501
        :type rate_max: list[float]
        """

        self._rate_max = rate_max

    @property
    def series_has_terminators(self):
        """Gets the series_has_terminators of this FeatureTimeSeries.  # noqa: E501

        Flag, specific to id features for a series. If true specifies that there are values that explicitly denote the end of a series.   # noqa: E501

        :return: The series_has_terminators of this FeatureTimeSeries.  # noqa: E501
        :rtype: bool
        """
        return self._series_has_terminators

    @series_has_terminators.setter
    def series_has_terminators(self, series_has_terminators):
        """Sets the series_has_terminators of this FeatureTimeSeries.

        Flag, specific to id features for a series. If true specifies that there are values that explicitly denote the end of a series.   # noqa: E501

        :param series_has_terminators: The series_has_terminators of this FeatureTimeSeries.  # noqa: E501
        :type series_has_terminators: bool
        """

        self._series_has_terminators = series_has_terminators

    @property
    def stop_on_terminator(self):
        """Gets the stop_on_terminator of this FeatureTimeSeries.  # noqa: E501

        Flag specific to id features for a series. If true specifies that a series must end on a terminator value.   # noqa: E501

        :return: The stop_on_terminator of this FeatureTimeSeries.  # noqa: E501
        :rtype: bool
        """
        return self._stop_on_terminator

    @stop_on_terminator.setter
    def stop_on_terminator(self, stop_on_terminator):
        """Sets the stop_on_terminator of this FeatureTimeSeries.

        Flag specific to id features for a series. If true specifies that a series must end on a terminator value.   # noqa: E501

        :param stop_on_terminator: The stop_on_terminator of this FeatureTimeSeries.  # noqa: E501
        :type stop_on_terminator: bool
        """

        self._stop_on_terminator = stop_on_terminator

    @property
    def time_feature(self):
        """Gets the time_feature of this FeatureTimeSeries.  # noqa: E501

        When True, the feature can be treated as the time feature for time series modeling. Any time feature must only be of type \"delta\" and 'rate_min' and 'rate_max' will not apply.   # noqa: E501

        :return: The time_feature of this FeatureTimeSeries.  # noqa: E501
        :rtype: bool
        """
        return self._time_feature

    @time_feature.setter
    def time_feature(self, time_feature):
        """Sets the time_feature of this FeatureTimeSeries.

        When True, the feature can be treated as the time feature for time series modeling. Any time feature must only be of type \"delta\" and 'rate_min' and 'rate_max' will not apply.   # noqa: E501

        :param time_feature: The time_feature of this FeatureTimeSeries.  # noqa: E501
        :type time_feature: bool
        """

        self._time_feature = time_feature

    def to_dict(self, serialize=False, exclude_null=False):
        """Returns the model properties as a dict"""
        result = {}

        def convert(x):
            if hasattr(x, "to_dict"):
                args = getfullargspec(x.to_dict).args
                if len(args) == 1:
                    return x.to_dict()
                elif 'exclude_null' in args:
                    return x.to_dict(serialize, exclude_null)
                else:
                    return x.to_dict(serialize)
            else:
                return x

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            attr = self.attribute_map.get(attr, attr) if serialize else attr
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: convert(x),
                    value
                ))
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], convert(item[1])),
                    value.items()
                ))
            elif value is None and (exclude_null or attr not in self.nullable_attributes):
                continue
            else:
                result[attr] = convert(value)

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, FeatureTimeSeries):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, FeatureTimeSeries):
            return True

        return self.to_dict() != other.to_dict()
