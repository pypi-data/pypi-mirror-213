# coding: utf-8

"""
    Diveplane API

    OpenAPI implementation for interacting with the Diveplane API.   # noqa: E501

    The version of the OpenAPI document: 23.7.1
    Contact: diveplane@diveplane.com
    Generated by: https://openapi-generator.tech
"""


try:
    from inspect import getfullargspec
except ImportError:
    from inspect import getargspec as getfullargspec
import pprint
import re  # noqa: F401
import six

from diveplane.openapi.configuration import Configuration


class FeatureAttributes(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'type': 'str',
        'auto_derive_on_train': 'FeatureAutoDeriveOnTrain',
        'bounds': 'dict[str, object]',
        'cycle_length': 'int',
        'data_type': 'str',
        'date_time_format': 'str',
        'decimal_places': 'int',
        'dependent_features': 'list[str]',
        'derived_feature_code': 'str',
        'dropna': 'bool',
        'id_feature': 'bool',
        'locale': 'str',
        'non_sensitive': 'bool',
        'observational_error': 'float',
        'original_type': 'FeatureDataType',
        'original_format': 'FeatureAttributesOriginalFormat',
        'post_process': 'str',
        'significant_digits': 'int',
        'subtype': 'str',
        'time_delta_format': 'str',
        'time_series': 'FeatureTimeSeries',
        'unique': 'bool'
    }

    attribute_map = {
        'type': 'type',
        'auto_derive_on_train': 'auto_derive_on_train',
        'bounds': 'bounds',
        'cycle_length': 'cycle_length',
        'data_type': 'data_type',
        'date_time_format': 'date_time_format',
        'decimal_places': 'decimal_places',
        'dependent_features': 'dependent_features',
        'derived_feature_code': 'derived_feature_code',
        'dropna': 'dropna',
        'id_feature': 'id_feature',
        'locale': 'locale',
        'non_sensitive': 'non_sensitive',
        'observational_error': 'observational_error',
        'original_type': 'original_type',
        'original_format': 'original_format',
        'post_process': 'post_process',
        'significant_digits': 'significant_digits',
        'subtype': 'subtype',
        'time_delta_format': 'time_delta_format',
        'time_series': 'time_series',
        'unique': 'unique'
    }

    nullable_attributes = [
    ]

    discriminator = None

    def __init__(self, type=None, auto_derive_on_train=None, bounds=None, cycle_length=None, data_type=None, date_time_format=None, decimal_places=None, dependent_features=None, derived_feature_code=None, dropna=None, id_feature=None, locale=None, non_sensitive=None, observational_error=None, original_type=None, original_format=None, post_process=None, significant_digits=None, subtype=None, time_delta_format=None, time_series=None, unique=None, local_vars_configuration=None):  # noqa: E501
        """FeatureAttributes - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration.get_default_copy()
        self.local_vars_configuration = local_vars_configuration

        self._type = None
        self._auto_derive_on_train = None
        self._bounds = None
        self._cycle_length = None
        self._data_type = None
        self._date_time_format = None
        self._decimal_places = None
        self._dependent_features = None
        self._derived_feature_code = None
        self._dropna = None
        self._id_feature = None
        self._locale = None
        self._non_sensitive = None
        self._observational_error = None
        self._original_type = None
        self._original_format = None
        self._post_process = None
        self._significant_digits = None
        self._subtype = None
        self._time_delta_format = None
        self._time_series = None
        self._unique = None

        self.type = type
        if auto_derive_on_train is not None:
            self.auto_derive_on_train = auto_derive_on_train
        if bounds is not None:
            self.bounds = bounds
        if cycle_length is not None:
            self.cycle_length = cycle_length
        if data_type is not None:
            self.data_type = data_type
        if date_time_format is not None:
            self.date_time_format = date_time_format
        if decimal_places is not None:
            self.decimal_places = decimal_places
        if dependent_features is not None:
            self.dependent_features = dependent_features
        if derived_feature_code is not None:
            self.derived_feature_code = derived_feature_code
        if dropna is not None:
            self.dropna = dropna
        if id_feature is not None:
            self.id_feature = id_feature
        if locale is not None:
            self.locale = locale
        if non_sensitive is not None:
            self.non_sensitive = non_sensitive
        if observational_error is not None:
            self.observational_error = observational_error
        if original_type is not None:
            self.original_type = original_type
        if original_format is not None:
            self.original_format = original_format
        if post_process is not None:
            self.post_process = post_process
        if significant_digits is not None:
            self.significant_digits = significant_digits
        if subtype is not None:
            self.subtype = subtype
        if time_delta_format is not None:
            self.time_delta_format = time_delta_format
        if time_series is not None:
            self.time_series = time_series
        if unique is not None:
            self.unique = unique

    @property
    def type(self):
        """Gets the type of this FeatureAttributes.  # noqa: E501

        The type of the feature which can be one of the following: - continuous - A continuous numeric value.   - Example: A feature describing temperature or humidity. - nominal - A numeric or string value with no ordering.   - Example: The name of a fruit. - ordinal - A nominal numeric value with ordering.   - Example: Rating scale, 1-5 stars.   # noqa: E501

        :return: The type of this FeatureAttributes.  # noqa: E501
        :rtype: str
        """
        return self._type

    @type.setter
    def type(self, type):
        """Sets the type of this FeatureAttributes.

        The type of the feature which can be one of the following: - continuous - A continuous numeric value.   - Example: A feature describing temperature or humidity. - nominal - A numeric or string value with no ordering.   - Example: The name of a fruit. - ordinal - A nominal numeric value with ordering.   - Example: Rating scale, 1-5 stars.   # noqa: E501

        :param type: The type of this FeatureAttributes.  # noqa: E501
        :type type: str
        """
        if self.local_vars_configuration.client_side_validation and type is None:  # noqa: E501
            raise ValueError("Invalid value for `type`, must not be `None`")  # noqa: E501
        allowed_values = ["continuous", "nominal", "ordinal"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and type not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `type` ({0}), must be one of {1}"  # noqa: E501
                .format(type, allowed_values)
            )

        self._type = type

    @property
    def auto_derive_on_train(self):
        """Gets the auto_derive_on_train of this FeatureAttributes.  # noqa: E501


        :return: The auto_derive_on_train of this FeatureAttributes.  # noqa: E501
        :rtype: FeatureAutoDeriveOnTrain
        """
        return self._auto_derive_on_train

    @auto_derive_on_train.setter
    def auto_derive_on_train(self, auto_derive_on_train):
        """Sets the auto_derive_on_train of this FeatureAttributes.


        :param auto_derive_on_train: The auto_derive_on_train of this FeatureAttributes.  # noqa: E501
        :type auto_derive_on_train: FeatureAutoDeriveOnTrain
        """

        self._auto_derive_on_train = auto_derive_on_train

    @property
    def bounds(self):
        """Gets the bounds of this FeatureAttributes.  # noqa: E501

        The bounds for the feature values to be generated in.   # noqa: E501

        :return: The bounds of this FeatureAttributes.  # noqa: E501
        :rtype: dict[str, object]
        """
        return self._bounds

    @bounds.setter
    def bounds(self, bounds):
        """Sets the bounds of this FeatureAttributes.

        The bounds for the feature values to be generated in.   # noqa: E501

        :param bounds: The bounds of this FeatureAttributes.  # noqa: E501
        :type bounds: dict[str, object]
        """

        self._bounds = bounds

    @property
    def cycle_length(self):
        """Gets the cycle_length of this FeatureAttributes.  # noqa: E501

        Cyclic features start at 0 and have a range of [0, cycle_length]. The cycle_length is the maximum value (exclusive) of the cycle for the feature with values exceeding the cycle_length normalized to the original cycle (e.g., cycles with length 360 for degrees will evaluate a 370 as 10 and 360 as 0). Negative values are not supported in cyclic features. Only applicable to continuous or ordinal features. - Examples:   - degrees: values should be 0-359, cycle_length = 360   - days: values should be 0-6, cycle_length = 7   - hours: values should be 0-23, cycle_length = 24   # noqa: E501

        :return: The cycle_length of this FeatureAttributes.  # noqa: E501
        :rtype: int
        """
        return self._cycle_length

    @cycle_length.setter
    def cycle_length(self, cycle_length):
        """Sets the cycle_length of this FeatureAttributes.

        Cyclic features start at 0 and have a range of [0, cycle_length]. The cycle_length is the maximum value (exclusive) of the cycle for the feature with values exceeding the cycle_length normalized to the original cycle (e.g., cycles with length 360 for degrees will evaluate a 370 as 10 and 360 as 0). Negative values are not supported in cyclic features. Only applicable to continuous or ordinal features. - Examples:   - degrees: values should be 0-359, cycle_length = 360   - days: values should be 0-6, cycle_length = 7   - hours: values should be 0-23, cycle_length = 24   # noqa: E501

        :param cycle_length: The cycle_length of this FeatureAttributes.  # noqa: E501
        :type cycle_length: int
        """

        self._cycle_length = cycle_length

    @property
    def data_type(self):
        """Gets the data_type of this FeatureAttributes.  # noqa: E501

        The feature value data type.  # noqa: E501

        :return: The data_type of this FeatureAttributes.  # noqa: E501
        :rtype: str
        """
        return self._data_type

    @data_type.setter
    def data_type(self, data_type):
        """Sets the data_type of this FeatureAttributes.

        The feature value data type.  # noqa: E501

        :param data_type: The data_type of this FeatureAttributes.  # noqa: E501
        :type data_type: str
        """
        allowed_values = ["number", "boolean"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and data_type not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `data_type` ({0}), must be one of {1}"  # noqa: E501
                .format(data_type, allowed_values)
            )

        self._data_type = data_type

    @property
    def date_time_format(self):
        """Gets the date_time_format of this FeatureAttributes.  # noqa: E501

        If specified, the feature assumed to be a continuous feature that is passed in the format specified by this string. - Examples:   - \"%Y-%m-%d-%H.%M.%S\"   - \"%A, %b %d, %Y\"   # noqa: E501

        :return: The date_time_format of this FeatureAttributes.  # noqa: E501
        :rtype: str
        """
        return self._date_time_format

    @date_time_format.setter
    def date_time_format(self, date_time_format):
        """Sets the date_time_format of this FeatureAttributes.

        If specified, the feature assumed to be a continuous feature that is passed in the format specified by this string. - Examples:   - \"%Y-%m-%d-%H.%M.%S\"   - \"%A, %b %d, %Y\"   # noqa: E501

        :param date_time_format: The date_time_format of this FeatureAttributes.  # noqa: E501
        :type date_time_format: str
        """

        self._date_time_format = date_time_format

    @property
    def decimal_places(self):
        """Gets the decimal_places of this FeatureAttributes.  # noqa: E501

        Rounding of decimal places, default is no rounding. If significant_digits is specified, then it rounds to the specified number of significant digits. If decimal_places is specified, then it ensures that output will be rounded at least to the number of decimal points past the integer as specified by decimal_places.   # noqa: E501

        :return: The decimal_places of this FeatureAttributes.  # noqa: E501
        :rtype: int
        """
        return self._decimal_places

    @decimal_places.setter
    def decimal_places(self, decimal_places):
        """Sets the decimal_places of this FeatureAttributes.

        Rounding of decimal places, default is no rounding. If significant_digits is specified, then it rounds to the specified number of significant digits. If decimal_places is specified, then it ensures that output will be rounded at least to the number of decimal points past the integer as specified by decimal_places.   # noqa: E501

        :param decimal_places: The decimal_places of this FeatureAttributes.  # noqa: E501
        :type decimal_places: int
        """

        self._decimal_places = decimal_places

    @property
    def dependent_features(self):
        """Gets the dependent_features of this FeatureAttributes.  # noqa: E501

        A list of features that this feature either depends on or features that depend on this feature. Should be used when there are multi-type value features that tightly depend on values based on other multi-type value features.   # noqa: E501

        :return: The dependent_features of this FeatureAttributes.  # noqa: E501
        :rtype: list[str]
        """
        return self._dependent_features

    @dependent_features.setter
    def dependent_features(self, dependent_features):
        """Sets the dependent_features of this FeatureAttributes.

        A list of features that this feature either depends on or features that depend on this feature. Should be used when there are multi-type value features that tightly depend on values based on other multi-type value features.   # noqa: E501

        :param dependent_features: The dependent_features of this FeatureAttributes.  # noqa: E501
        :type dependent_features: list[str]
        """

        self._dependent_features = dependent_features

    @property
    def derived_feature_code(self):
        """Gets the derived_feature_code of this FeatureAttributes.  # noqa: E501

        Code defining how the value for this feature could be derived if this feature is specified as a \"derived_context_feature\" or a \"derived_action_feature\" during react flows. For react_series, the data referenced is the accumulated series data (as a list of rows), and for non-series reacts, the data is the one single row. Each row is comprised of all the combined context and action features. Referencing data in these rows uses 0-based indexing, where the current row index is 0, the previous row's is 1, etc. Specified code may do simple logic and numeric operations on feature values referenced via feature name and row offset.  Examples:   - \"#x 1\" - Use the value for feature 'x' from the previously processed row (offset of 1, one lag value).   - \"(- #y 0 #x 1)\" - Feature 'y' value from current (offset 0) row  minus feature 'x' value from previous (offest 1) row .   # noqa: E501

        :return: The derived_feature_code of this FeatureAttributes.  # noqa: E501
        :rtype: str
        """
        return self._derived_feature_code

    @derived_feature_code.setter
    def derived_feature_code(self, derived_feature_code):
        """Sets the derived_feature_code of this FeatureAttributes.

        Code defining how the value for this feature could be derived if this feature is specified as a \"derived_context_feature\" or a \"derived_action_feature\" during react flows. For react_series, the data referenced is the accumulated series data (as a list of rows), and for non-series reacts, the data is the one single row. Each row is comprised of all the combined context and action features. Referencing data in these rows uses 0-based indexing, where the current row index is 0, the previous row's is 1, etc. Specified code may do simple logic and numeric operations on feature values referenced via feature name and row offset.  Examples:   - \"#x 1\" - Use the value for feature 'x' from the previously processed row (offset of 1, one lag value).   - \"(- #y 0 #x 1)\" - Feature 'y' value from current (offset 0) row  minus feature 'x' value from previous (offest 1) row .   # noqa: E501

        :param derived_feature_code: The derived_feature_code of this FeatureAttributes.  # noqa: E501
        :type derived_feature_code: str
        """

        self._derived_feature_code = derived_feature_code

    @property
    def dropna(self):
        """Gets the dropna of this FeatureAttributes.  # noqa: E501

        When true, samples where the feature value is NaN are removed.  # noqa: E501

        :return: The dropna of this FeatureAttributes.  # noqa: E501
        :rtype: bool
        """
        return self._dropna

    @dropna.setter
    def dropna(self, dropna):
        """Sets the dropna of this FeatureAttributes.

        When true, samples where the feature value is NaN are removed.  # noqa: E501

        :param dropna: The dropna of this FeatureAttributes.  # noqa: E501
        :type dropna: bool
        """

        self._dropna = dropna

    @property
    def id_feature(self):
        """Gets the id_feature of this FeatureAttributes.  # noqa: E501

        Flag should be set to true if this feature contains nominal IDs.  # noqa: E501

        :return: The id_feature of this FeatureAttributes.  # noqa: E501
        :rtype: bool
        """
        return self._id_feature

    @id_feature.setter
    def id_feature(self, id_feature):
        """Sets the id_feature of this FeatureAttributes.

        Flag should be set to true if this feature contains nominal IDs.  # noqa: E501

        :param id_feature: The id_feature of this FeatureAttributes.  # noqa: E501
        :type id_feature: bool
        """

        self._id_feature = id_feature

    @property
    def locale(self):
        """Gets the locale of this FeatureAttributes.  # noqa: E501

        Locale for the date time format, default is whatever is on the platform.   # noqa: E501

        :return: The locale of this FeatureAttributes.  # noqa: E501
        :rtype: str
        """
        return self._locale

    @locale.setter
    def locale(self, locale):
        """Sets the locale of this FeatureAttributes.

        Locale for the date time format, default is whatever is on the platform.   # noqa: E501

        :param locale: The locale of this FeatureAttributes.  # noqa: E501
        :type locale: str
        """

        self._locale = locale

    @property
    def non_sensitive(self):
        """Gets the non_sensitive of this FeatureAttributes.  # noqa: E501

        Represents all the categorical features that are not sensitive. It's recommended that all nominal values be represented as either 'int-id' subtype or as other available nominal types using the \"subtype\" attribute. However, if the nominal feature is `non_sensitive`, setting it to true will bypass the `subtype` requirement.   # noqa: E501

        :return: The non_sensitive of this FeatureAttributes.  # noqa: E501
        :rtype: bool
        """
        return self._non_sensitive

    @non_sensitive.setter
    def non_sensitive(self, non_sensitive):
        """Sets the non_sensitive of this FeatureAttributes.

        Represents all the categorical features that are not sensitive. It's recommended that all nominal values be represented as either 'int-id' subtype or as other available nominal types using the \"subtype\" attribute. However, if the nominal feature is `non_sensitive`, setting it to true will bypass the `subtype` requirement.   # noqa: E501

        :param non_sensitive: The non_sensitive of this FeatureAttributes.  # noqa: E501
        :type non_sensitive: bool
        """

        self._non_sensitive = non_sensitive

    @property
    def observational_error(self):
        """Gets the observational_error of this FeatureAttributes.  # noqa: E501

        Observed error for feature, if known.  # noqa: E501

        :return: The observational_error of this FeatureAttributes.  # noqa: E501
        :rtype: float
        """
        return self._observational_error

    @observational_error.setter
    def observational_error(self, observational_error):
        """Sets the observational_error of this FeatureAttributes.

        Observed error for feature, if known.  # noqa: E501

        :param observational_error: The observational_error of this FeatureAttributes.  # noqa: E501
        :type observational_error: float
        """

        self._observational_error = observational_error

    @property
    def original_type(self):
        """Gets the original_type of this FeatureAttributes.  # noqa: E501


        :return: The original_type of this FeatureAttributes.  # noqa: E501
        :rtype: FeatureDataType
        """
        return self._original_type

    @original_type.setter
    def original_type(self, original_type):
        """Sets the original_type of this FeatureAttributes.


        :param original_type: The original_type of this FeatureAttributes.  # noqa: E501
        :type original_type: FeatureDataType
        """

        self._original_type = original_type

    @property
    def original_format(self):
        """Gets the original_format of this FeatureAttributes.  # noqa: E501


        :return: The original_format of this FeatureAttributes.  # noqa: E501
        :rtype: FeatureAttributesOriginalFormat
        """
        return self._original_format

    @original_format.setter
    def original_format(self, original_format):
        """Sets the original_format of this FeatureAttributes.


        :param original_format: The original_format of this FeatureAttributes.  # noqa: E501
        :type original_format: FeatureAttributesOriginalFormat
        """

        self._original_format = original_format

    @property
    def post_process(self):
        """Gets the post_process of this FeatureAttributes.  # noqa: E501

        Custom Amalgam code that is called on resulting values of this feature during react operations.  # noqa: E501

        :return: The post_process of this FeatureAttributes.  # noqa: E501
        :rtype: str
        """
        return self._post_process

    @post_process.setter
    def post_process(self, post_process):
        """Sets the post_process of this FeatureAttributes.

        Custom Amalgam code that is called on resulting values of this feature during react operations.  # noqa: E501

        :param post_process: The post_process of this FeatureAttributes.  # noqa: E501
        :type post_process: str
        """

        self._post_process = post_process

    @property
    def significant_digits(self):
        """Gets the significant_digits of this FeatureAttributes.  # noqa: E501

        Rounding to significant digits, default is no rounding.   # noqa: E501

        :return: The significant_digits of this FeatureAttributes.  # noqa: E501
        :rtype: int
        """
        return self._significant_digits

    @significant_digits.setter
    def significant_digits(self, significant_digits):
        """Sets the significant_digits of this FeatureAttributes.

        Rounding to significant digits, default is no rounding.   # noqa: E501

        :param significant_digits: The significant_digits of this FeatureAttributes.  # noqa: E501
        :type significant_digits: int
        """

        self._significant_digits = significant_digits

    @property
    def subtype(self):
        """Gets the subtype of this FeatureAttributes.  # noqa: E501

        The type used in novel nominal substitution.  # noqa: E501

        :return: The subtype of this FeatureAttributes.  # noqa: E501
        :rtype: str
        """
        return self._subtype

    @subtype.setter
    def subtype(self, subtype):
        """Sets the subtype of this FeatureAttributes.

        The type used in novel nominal substitution.  # noqa: E501

        :param subtype: The subtype of this FeatureAttributes.  # noqa: E501
        :type subtype: str
        """

        self._subtype = subtype

    @property
    def time_delta_format(self):
        """Gets the time_delta_format of this FeatureAttributes.  # noqa: E501

        Format of the delta for date time features, default is 'seconds'. Valid values are: milliseconds, seconds, minutes, hours, days, weeks, years.   # noqa: E501

        :return: The time_delta_format of this FeatureAttributes.  # noqa: E501
        :rtype: str
        """
        return self._time_delta_format

    @time_delta_format.setter
    def time_delta_format(self, time_delta_format):
        """Sets the time_delta_format of this FeatureAttributes.

        Format of the delta for date time features, default is 'seconds'. Valid values are: milliseconds, seconds, minutes, hours, days, weeks, years.   # noqa: E501

        :param time_delta_format: The time_delta_format of this FeatureAttributes.  # noqa: E501
        :type time_delta_format: str
        """
        allowed_values = ["milliseconds", "seconds", "minutes", "hours", "days", "weeks", "years"]  # noqa: E501
        if self.local_vars_configuration.client_side_validation and time_delta_format not in allowed_values:  # noqa: E501
            raise ValueError(
                "Invalid value for `time_delta_format` ({0}), must be one of {1}"  # noqa: E501
                .format(time_delta_format, allowed_values)
            )

        self._time_delta_format = time_delta_format

    @property
    def time_series(self):
        """Gets the time_series of this FeatureAttributes.  # noqa: E501


        :return: The time_series of this FeatureAttributes.  # noqa: E501
        :rtype: FeatureTimeSeries
        """
        return self._time_series

    @time_series.setter
    def time_series(self, time_series):
        """Sets the time_series of this FeatureAttributes.


        :param time_series: The time_series of this FeatureAttributes.  # noqa: E501
        :type time_series: FeatureTimeSeries
        """

        self._time_series = time_series

    @property
    def unique(self):
        """Gets the unique of this FeatureAttributes.  # noqa: E501

        Specify feature as only having unique values. (Only applicable to nominals features)  # noqa: E501

        :return: The unique of this FeatureAttributes.  # noqa: E501
        :rtype: bool
        """
        return self._unique

    @unique.setter
    def unique(self, unique):
        """Sets the unique of this FeatureAttributes.

        Specify feature as only having unique values. (Only applicable to nominals features)  # noqa: E501

        :param unique: The unique of this FeatureAttributes.  # noqa: E501
        :type unique: bool
        """

        self._unique = unique

    def to_dict(self, serialize=False, exclude_null=False):
        """Returns the model properties as a dict"""
        result = {}

        def convert(x):
            if hasattr(x, "to_dict"):
                args = getfullargspec(x.to_dict).args
                if len(args) == 1:
                    return x.to_dict()
                elif 'exclude_null' in args:
                    return x.to_dict(serialize, exclude_null)
                else:
                    return x.to_dict(serialize)
            else:
                return x

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            attr = self.attribute_map.get(attr, attr) if serialize else attr
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: convert(x),
                    value
                ))
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], convert(item[1])),
                    value.items()
                ))
            elif value is None and (exclude_null or attr not in self.nullable_attributes):
                continue
            else:
                result[attr] = convert(value)

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, FeatureAttributes):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, FeatureAttributes):
            return True

        return self.to_dict() != other.to_dict()
