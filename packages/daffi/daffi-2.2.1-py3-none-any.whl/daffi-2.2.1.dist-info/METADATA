Metadata-Version: 2.1
Name: daffi
Version: 2.2.1
Summary: Daffi is fast, simple and lightweight library for inter process communication
Project-URL: Documentation, https://600apples.github.io/dafi/
Project-URL: Source, https://github.com/600apples/dafi
Author-email: Volodymyr Boiko <600apples@gmail.com>
License-Expression: MIT
License-File: LICENSE.txt
Keywords: async,distributed,grpc,job,python,queue,rpc,stream,task
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: System Administrators
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Topic :: Internet
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Software Development :: Object Brokering
Classifier: Topic :: Software Development :: Testing
Classifier: Topic :: System :: Clustering
Classifier: Topic :: System :: Distributed Computing
Classifier: Topic :: System :: Monitoring
Classifier: Topic :: System :: Networking
Classifier: Topic :: System :: Systems Administration
Requires-Python: >=3.8
Requires-Dist: anyio>=3.6.2
Requires-Dist: cached-property>=1.5.2
Requires-Dist: cachetools>=5.3.0
Requires-Dist: colorama>=0.4.6; sys_platform == 'win32'
Requires-Dist: dill>=0.3.6
Requires-Dist: grpcio>=1.51.3
Requires-Dist: protobuf>=4.21.12
Requires-Dist: tblib>=1.7.0
Requires-Dist: tenacity>=8.1.0
Requires-Dist: typing-extensions>=4.4.0
Requires-Dist: uvloop>=0.17.0; sys_platform != 'win32'
Description-Content-Type: text/markdown

<h1> 
    <img src="https://600apples.github.io/dafi/images/logo.png"
    width="40"
    height="40"
    style="float: left;">
    Daffi
</h1>


![test and validate](https://github.com/600apples/dafi/actions/workflows/test_and_validate.yml/badge.svg)
![publish docs](https://github.com/600apples/dafi/actions/workflows/publish_docs.yml/badge.svg)
![coverage](https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/600apples/c64b2cee548575858e40834754432018/raw/covbadge.json)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)
[![Linux](https://svgshare.com/i/Zhy.svg)](https://svgshare.com/i/Zhy.svg)
[![macOS](https://svgshare.com/i/ZjP.svg)](https://svgshare.com/i/ZjP.svg)
[![Downloads](https://static.pepy.tech/badge/daffi/month)](https://pepy.tech/project/daffi)

Daffi facilitates remote computing and enables remote procedure calls between multiple endpoints.
It supports many-to-many relationships between endpoints, allowing for seamless communication between distributed systems.
The library abstracts the complexities of remote computing and provides a user-friendly interface for initiating and managing remote procedure calls.
It also offers various features such as fault tolerance, load balancing, streaming and security, to ensure reliable and secure communication between endpoints.

Daffi comprises three primary classes:

- *Global* - Initialization entrypoint. Once *Global* object is initialized application can respond on remote requests and trigger remote callbacks itself.
- *Callback* - Represents a collection of methods encapsulated in a class inherited from *Callback* or a standalone function decorated with the *callback* decorator. These functions/methods can be triggered from another process.
- *Fetcher* - Represents a collection of methods encapsulated in a class inherited from *Fetcher* or a standalone function decorated with the *fetcher* decorator. These functions/methods serve as triggers for the corresponding callbacks defined in another process.

## Documentation

View full documentation at: [https://600apples.github.io/dafi/](https://600apples.github.io/dafi/)


## Basic example

You need to create two files `shopping_service.py` and `shopper.py`

`shopping_service.py` - represents a set of remote callbacks that can be triggered by a client application.

`shopper.py` - represents shopping_service client (fetcher)

#### Class based approach


`shopping_service.py`:
```python
import logging
from daffi import Global
from daffi.registry import Callback

logging.basicConfig(level=logging.INFO)


class ShoppingService(Callback):
    auto_init = True # class is automatically initialized, eliminating the need to manually create an object.

    def __post_init__(self):
        self.shopping_list = []

    def get_items(self):
        """Return all items that are currently present in shopping list"""
        return self.shopping_list

    def add_item(self, item):
        """Add new item to shopping list"""
        self.shopping_list.append(item)

    def clear_items(self):
        """Clear shopping list"""
        self.shopping_list.clear()


if __name__ == '__main__':
    Global(init_controller=True, host="localhost", port=8888).join()
```
(This script is complete, it should run "as is")


`shopper.py`:
```python
import logging
from daffi import Global
from daffi.decorators import alias
from daffi.registry import Fetcher

logging.basicConfig(level=logging.INFO)


class Shopper(Fetcher):
    """
    Note: Functions without a body are treated as proxies for remote callbacks.
    All arguments provided to this function will be sent to the remote service as-is.
    """

    def get_items(self):
        """Return all items that are currently present in shopping list."""
        pass

    def add_item(self, item):
        """Add new item to shopping list."""
        pass

    def clear_items(self):
        """Clear shopping list"""
        pass

    @alias("add_item")
    def add_many_items(self, *items):
        """
        Alias for `add_item` callback.
        This function shows streaming capabilities for transferring data from one service to another.
        """
        for item in items:
            yield item


if __name__ == '__main__':
    g = Global(host="localhost", port=8888)

    shopper = Shopper()
    items = shopper.get_items()
    print(items)

    shopper.add_item("orange")
    items = shopper.get_items()
    print(items)

    shopper.add_many_items("bread", "cheese")
    items = shopper.get_items()
    print(items)

    shopper.clear_items()
    items = shopper.get_items()
    print(items)

    g.stop()
```
(This script is complete, it should run "as is")

To check the full example, you need to execute two scripts in separate terminals

```bash
python3 shopping_service.py

...
INFO 2023-03-27 19:49:45 | controller[0x91adb83e] | Controller has been started successfully. Process identificator: '0x91adb83e'. Connection info: tcp: [ host '[::]', port: 8888 ]
INFO 2023-03-27 19:49:45 | node[0x91adb83e] | Node has been started successfully. Process identificator: '0x91adb83e'. Connection info: tcp: [ host '[::]', port: 8888 ]
```

```bash
python3 shopper.py

...
INFO 2023-03-27 19:53:15 | node[0xd7e5d488] | Node has been started successfully. Process identificator: '0xd7e5d488'. Connection info: tcp: [ host '[::]', port: 8888 ]
[]
['orange']
['orange', 'bread', 'cheese']
[]
INFO 2023-03-27 19:53:15 | node[0xd7e5d488] | Node stopped.
```

### Decorators base approach

`shopping_service.py`:
```python
import logging
from daffi import Global
from daffi.decorators import callback

logging.basicConfig(level=logging.INFO)

shopping_list = []


@callback
def get_items():
    """Return all items that are currently present in shopping list"""
    return shopping_list


@callback
def add_item(item):
    """Add new item to shopping list"""
    shopping_list.append(item)


@callback
def clear_items():
    """Clear shopping list"""
    shopping_list.clear()


if __name__ == '__main__':
    Global(init_controller=True, host="localhost", port=8888).join()
```
(This script is complete, it should run "as is")


`shopper.py`:
```python
"""
Note: Functions without a body are treated as proxies for remote callbacks.
    All arguments provided to this function will be sent to the remote service as-is.
"""
import logging
from daffi import Global
from daffi.decorators import alias, fetcher

logging.basicConfig(level=logging.INFO)


@fetcher
def get_items():
    """Return all items that are currently present in shopping list."""
    pass


@fetcher
def add_item(item):
    """Add new item to shopping list."""
    pass


@fetcher
def clear_items():
    """Add new item to shopping list."""
    pass


@alias("add_item")
@fetcher
def add_many_items(*items):
    """
    Alias for `add_item` callback.
    This function shows streaming capabilities for transferring data from one service to another.
    """
    for item in items:
        yield item


if __name__ == '__main__':
    g = Global(host="localhost", port=8888)

    items = get_items()
    print(items)

    add_item("orange")
    items = get_items()
    print(items)

    add_many_items("bread", "cheese")
    items = get_items()
    print(items)

    clear_items()
    items = get_items()
    print(items)

    g.stop()
```
(This script is complete, it should run "as is")

To check the full example, you need to execute two scripts in separate terminals

```bash
python3 shopping_service.py

...
INFO 2023-03-27 20:31:27 | controller[0xbac16ef4] | Controller has been started successfully. Process identificator: '0xbac16ef4'. Connection info: tcp: [ host '[::]', port: 8888 ]
INFO 2023-03-27 20:31:27 | node[0xbac16ef4] | Node has been started successfully. Process identificator: '0xbac16ef4'. Connection info: tcp: [ host '[::]', port: 8888 ]
```

```bash
python3 shopper.py

...
INFO 2023-03-27 20:31:43 | node[0xb9e10444] | Node has been started successfully. Process identificator: '0xb9e10444'. Connection info: tcp: [ host '[::]', port: 8888 ]
[]
['orange']
['orange', 'bread', 'cheese']
[]
INFO 2023-03-27 20:31:44 | node[0xb9e10444] | Node stopped.
```
